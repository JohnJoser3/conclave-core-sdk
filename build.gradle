plugins {
    id 'com.github.johnrengelman.shadow' version '6.0.0' apply false
    id "com.github.ben-manes.versions" version "0.27.0"
    id 'base'
    id 'idea'
    id 'org.jetbrains.dokka' version '0.10.1'
}

apply from: 'versions.gradle'
apply from: 'common.gradle'

repositories {
    jcenter()
}

static Map<String, String> createEnvironment(String... names) {
    return names.collectEntries { [(it): System.getenv(it)] }
}

ext {
    environment = createEnvironment(
            'OBLIVIUM_MAVEN_URL',
            'OBLIVIUM_MAVEN_REPOSITORY',
            'OBLIVIUM_MAVEN_USERNAME',
            'OBLIVIUM_MAVEN_PASSWORD',
            'OBLIVIUM_CONTAINER_REGISTRY_URL'
    )
}

import groovy.io.FileType

// This code allows the user to run gradle like this: ./gradlew -PexcludeNative
// and the native components will be downloaded instead of built locally. This
// can speed things up a lot if you aren't intending to change them!
def includeNative = findProperty('excludeNative') == null
def nativeSubmodulesToSubstitute = [
        ':cpp:native-host:native-host-simulation',
        ':cpp:native-host:native-host-debug',
        ':cpp:native-host:native-host-release',
        ':cpp:native-host-shared',
        ':cpp:native-enclave:native-enclave-simulation',
        ':cpp:native-enclave:native-enclave-debug',
        ':cpp:native-enclave:native-enclave-release',
        ':cpp:native-sign-tool',
        ':cpp:native-gdb',
        ':cpp:native-binutils'
]

// Allow the user to move the default build location. This is helpful for improving the
// atrocious performance of Mac Docker, which otherwise will try to build everything on
// the super-slow osxfuse filesystem. This way it can be relocated to a (faster) Linux
// native FS, or in extremis even a ramdisk.
def topDir = project.rootDir
def buildDirLocationOverride = findProperty('buildDirOverride')
if (buildDirLocationOverride != null) {
    println("Storing build output in $buildDirLocationOverride")
    allprojects {
        buildDir = "$buildDirLocationOverride/${topDir.relativePath(project.buildDir)}"
    }
}

subprojects {
    repositories {
        mavenCentral()
        jcenter()
        maven {
            url = "https://software.r3.com/artifactory/sgxjvm"
            credentials {
                username = environment.OBLIVIUM_MAVEN_USERNAME
                password = environment.OBLIVIUM_MAVEN_PASSWORD
            }
        }
    }

    // To create deterministic builds we want to ensure all archive tasks
    // use a reproducible file order and use consistent file timestamps
    tasks.withType(AbstractArchiveTask) {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    tasks.withType(Test) {
        useJUnitPlatform {
            if (findProperty("hardwareTests") == null) {
                excludeTags("hardware")
            } else {
                includeTags("hardware")
            }
        }
    }

    configurations {
        compile {
            // We want to use SLF4J's version of these bindings: jcl-over-slf4j
            // Remove any transitive dependency on Apache's version.
            exclude group: 'commons-logging', module: 'commons-logging'
        }

        if (project.name.startsWith("conclave-")) {
            // Shaded dependencies should not be added to the runtime classpath so they are declared as compileOnly.
            // However compileOnly does not extend to the test configuration so we add that.
            testImplementation.extendsFrom(compileOnly)
        }

        // Allow -PexcludeNative to do builds with downloaded artifacts instead of locally built artifacts.
        if (includeNative) {
            all {
                for (submodule in nativeSubmodulesToSubstitute) {
                    def submoduleProject = project(submodule)
                    resolutionStrategy.dependencySubstitution {
                        substitute module("${submoduleProject.getGroup()}:${submoduleProject.getName()}") with project(submodule)
                    }
                }
            }
        }
    }
}

// region Docsite building
//
// This part of the build handles the creation of the EXTERNAL docsite. The internal docsite is not built automatically
// at this time: run `mkdocs serve` in the internal-docs directory yourself to view it.

// Dokka is the tool that reads KDoc comments from Kotlin and produces an API website.
dokka {
    // We will use the JavaDoc styling for now, to make Conclave more appealing to Java developers. We may do what
    // Corda does and offer a "Kotlin theme" site later.
    outputFormat = 'javadoc'

    // We output into the site source directory to avoid warnings (and associated warning blindness) caused when mkdocs
    // tries to check links to the JavaDocs and finds they're missing. This causes a bit of disk space bloat when
    // the files are copied to the docs/build directory but the cost is small and worth it.
    outputDirectory = "docs/docs/api"

    // These modules/directories contain source code defining the exported API.
    subProjects = [
            "conclave-common",
            "conclave-enclave",
            "conclave-host",
            "conclave-client",
            "conclave-testing",
            "conclave-mail"
    ]
    def apiDirectories = files(subProjects.collect { "$it/src/main/kotlin" })

    // Find a list of packages that shouldn't appear in the API documentation.
    def internalPackagePrefixes = {
        def prefixes = []
        // Kotlin allows packages to deviate from the directory structure, but let's assume they don't:
        apiDirectories.collect { sourceDir ->
            sourceDir.traverse(type: FileType.DIRECTORIES) {
                if ((it.name == 'internal') || (it.name == 'kotlin')) {
                    prefixes.add sourceDir.toPath().relativize(it.toPath()).toString().replace(File.separator, '.')
                }
            }
        }
        prefixes
    }()

    configuration {
        moduleName = "Conclave"
        jdkVersion = 8
        reportUndocumented = false
        skipDeprecated = true  // Don't want users seeing deprecated stuff, they can call it up in their IDE if they need it.

        // Suppress each internal package.
        internalPackagePrefixes.collect { packagePrefix ->
            perPackageOption {
                prefix = packagePrefix
                suppress = true
            }
        }
    }
}

// Allow the option to exclude dokka from the SDK build.
// Important: This should only be used when building with a Java version that does not work
// with Dokka (currently anything greater than 8) to allow the SDK build to continue. It will
// result in an SDK build with the API documentation missing so should never be used for
// production builds.
def excludeDokka = findProperty('excludeDokka')
if (excludeDokka == null) {
    // This is here so we can add other Dokka formats in future (e.g. Kotlin's own API docs theme)
    task apidocs(dependsOn: ['dokka'])

    task packageJavadoc(type: Jar, dependsOn: ['dokka']) {
        from dokka
        archiveClassifier.set('javadoc')
    }
} else {
    // Dummy tasks to exclude dokka
    task apidocs()
    task packageJavadoc(type: Jar) {
        archiveClassifier.set('javadoc')
    }
}

// Dokka does not always translate kotlin code into pure java documentation. We can use this
// task to perform some pre-processing between generating the HTML and making the documentation site.
task preprocessdocs(type: Exec, dependsOn: ['apidocs']) {
    description = "Performs processing on the documentation generated using the apidocs task prior to running mkdocs."
    commandLine("./preprocess-docsite.sh")
    workingDir("docs")
    inputs.files(fileTree("docs/docs/api"))
    outputs.dir("docs/docs/api")
}

task mkdocs(type: Exec, dependsOn: ['preprocessdocs']) {
    description = "Runs the mkdocs tool to produce the static HTML website we expose to end users."
    commandLine("./make-docsite.sh")
    workingDir("docs")
    inputs.files(fileTree("docs/docs"))
    outputs.dir("docs/build")
}

task cleanDocs {
    delete 'docs/build'
    delete 'docs/docs/api'
    delete 'docs/virtualenv'
}

tasks['clean'].dependsOn(cleanDocs)

// This task has to be called "buildDocs" because it's invoked by the
// https://github.com/corda/corda-docs-builder tool from CI.
task buildDocs(dependsOn: ['mkdocs'])
dokka.shouldRunAfter mkdocs
// endregion

//region Publishing
class PublishedProject {
    String projectPath
    String description
}
List<PublishedProject> publishedProjects = [
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-simulation',
                description: 'Partially linked Conclave enclave linked with simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-debug',
                description: 'Partially linked Conclave enclave linked with debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-release',
                description: 'Partially linked Conclave enclave linked with release libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-simulation',
                description: 'Native Conclave host libraries linked with simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-debug',
                description: 'Native Conclave host libraries linked with debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-release',
                description: 'Native Conclave host libraries linked with release libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host-shared',
                description: 'Native Conclave host libraries shared between simulation, debug and release',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-gdb',
                description: 'The Intel Linux SDK gdb plugin and wrapper',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-sign-tool',
                description: 'The Intel Linux SDK signing tool',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-binutils',
                description: 'Pinned version of essential binutils tools',
        ),
        new PublishedProject(
                projectPath: ':cpp:linux-sgx:linux-sgx-simulation',
                description: 'SGX SDK simulation libraries and headers',
        ),
        new PublishedProject(
                projectPath: ':cpp:linux-sgx:linux-sgx-debug',
                description: 'SGX SDK debug libraries and headers',
        ),
        new PublishedProject(
                projectPath: ':cpp:linux-sgx:linux-sgx-release',
                description: 'SGX SDK release libraries and headers',
        ),
        new PublishedProject(
                projectPath: ':cpp:macos-binutils',
                description: 'Binutils for Mac OS',
        ),
        new PublishedProject(
                projectPath: ':cpp:macos-sign-tool',
                description: 'SGX sign tool for Mac OS',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-substratevm:native-substratevm-simulation',
                description: 'SubstrateVM stubs, JNI and EDL simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-substratevm:native-substratevm-debug',
                description: 'SubstrateVM stubs, JNI and EDL debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-substratevm:native-substratevm-release',
                description: 'SubstrateVM stubs, JNI and EDL release libraries',
        ),
        new PublishedProject(
                projectPath: ':conclave-common',
                description: 'Conclave API common to enclave, host and client',
        ),
        new PublishedProject(
                projectPath: ':conclave-enclave',
                description: 'Conclave enclave API',
        ),
        new PublishedProject(
                projectPath: ':conclave-host',
                description: 'Conclave host API',
        ),
        new PublishedProject(
                projectPath: ':conclave-client',
                description: 'Conclave client API',
        ),
        new PublishedProject(
                projectPath: ':conclave-mail',
                description: 'Conclave mail API',
        ),
        new PublishedProject(
                projectPath: ':conclave-testing',
                description: 'Conclave testing API',
        ),
        new PublishedProject(
                projectPath: ':plugin-enclave-gradle',
                description: 'Conclave Gradle plugin for creating enclaves'
        ),
        new PublishedProject(
                projectPath: ':graal',
                description: 'Graal distribution including SubstrateVM and tools'
        ),
        new PublishedProject(
                projectPath: ':containers:conclave-build',
                description: 'Conclave docker container for native-image builds'
        )
]

// We only enable publish if native parts of the build are included.
// We create a safeguard task to check this.
task publish {
    doFirst {
        if (!includeNative) {
            throw new Exception('Native artifacts aren\'t built, not publishing')
        }
    }
}

if (includeNative) {
    for (published in publishedProjects) {
        def project = project(published.projectPath)
        def description = published.description
        project.pluginManager.apply('java')
        project.pluginManager.apply('maven-publish')
        // We shade certain libraries into the Conclave API jars to avoid any potential versioning issues in Conclave apps
        // which might use different versions of these libraries.
        if (published.projectPath.startsWith(":conclave-")) {
            project.pluginManager.apply('com.github.johnrengelman.shadow')
            project.shadowJar {
                if (project.name == "conclave-mail" || project.name == "conclave-common") {
                    // Only conclave-mail and conclave-common need to have (some) of their dependencies shaded. These
                    // dependencies are in the compileOnly configuration.
                    configurations = [ project.configurations.compileOnly ]
                    exclude '**/pom.xml'
                    exclude '**/pom.properties'
                    exclude 'module-info.class'
                    mergeServiceFiles()
                    if (project.name == "conclave-mail") {
                        // Only conclave-mail, as the root in the dependency tree, will contain the shaded kotlin. Everything
                        // else depends on conclave-mail (transitively) and so will inherit the shaded version.
                        dependencies {
                            it.include(dependency("org.jetbrains.kotlin:"))
                        }
                    } else {
                        // Only conclave-common needs to contain the shaded Jackson library. Anything else that needs Jackson,
                        // e.g. conclave-host, can inherit this shaded version.
                        dependencies {
                            it.include(dependency("com.fasterxml.jackson.*:"))
                        }
                    }
                } else {
                    // The remaining modules are not shading anything so we turn it off.
                    configurations = []
                }
                exclude 'META-INF/*.kotlin_module'
                exclude '**/*.kotlin_metadata'
                exclude '**/*.kotlin_builtins'
                // Everyone needs to have their import lines modified to the new shaded ones.
                relocate 'com.fasterxml.jackson', 'com.r3.conclave.shaded.jackson'
                relocate 'kotlin', 'com.r3.conclave.shaded.kotlin'
                // Replace the output of the "jar" task with this one.
                archiveClassifier = ''
            }
        }
        project.publishing {
            publications {
                maven(MavenPublication) {
                    from project.components.java
                    pom.description = description
                    // Only publish JavaDocs for the Conclave modules, as the others aren't meant to be used.
                    if (published.projectPath.startsWith(":conclave-"))
                        artifact packageJavadoc
                }
            }
            repositories {
                maven {
                    name = "artifactory"
                    url = "${environment.OBLIVIUM_MAVEN_URL}/${environment.OBLIVIUM_MAVEN_REPOSITORY}"
                    credentials {
                        username = environment.OBLIVIUM_MAVEN_USERNAME
                        password = environment.OBLIVIUM_MAVEN_PASSWORD
                    }
                }
                maven {    // This section implicitly creates the publishAllPublicationsToSdkRepoRepository target.
                    name = "sdkRepo"
                    url = "$buildDir/sdk/repo"
                }
            }
        }
    }
}

// To speed up IntelliJ indexing
idea {
    module {
        excludeDirs = [
                file("$projectDir/cpp/avian/build"),
                file("$projectDir/cpp/openjdk8"),
                file("$projectDir/cpp/.idea"),
                file("$projectDir/scripts/build")
        ]
    }
}
//endregion


//region SDK artifact creation
//
// This set of rules creates the tarball of the SDK that we ship to our users. It consists of a local Maven repository
// which contains all the JARs and native artifacts needed for the plugins, the docsite, and extra files like
// a readme and the patches we are obliged to release under the GPL.
//
// The publishAllPublicationsToSdkRepoRepository target is synthesised automatically by the maven-publish Gradle
// plugin, based on the repositories block inside the if(includeNative) block above.
task sdkRepo {
    dependsOn = publishedProjects.collect { "${it.projectPath}:publishAllPublicationsToSdkRepoRepository" }
}

task zipGPL2Sources(type: Zip) {
    group = "SDK Build"
    description = "Zip up codebases we statically link with OpenJDK, to comply with our GPL2 obligations"
    archiveFileName = "sources.zip"
    destinationDirectory = file("$buildDir/sdk")
    reproducibleFileOrder = true
    from("cpp/avian") {
        into "avian"
        // Avian doesn't respect the default build location yet.
        exclude "build/**"
    }
    from("cpp/jvm-enclave-avian") {
        into "jvm-enclave-avian"
    }
    from("cpp/jvm-enclave-common") {
        into "jvm-enclave-common"
    }
    from("cpp/jvm-host-enclave-common") {
        into "jvm-host-enclave-common"
    }
    from("cpp/jvm-edl") {
        into "jvm-edl"
    }
    from("graal/patches") {
        into "graal"
    }
}

// Copy things like the README file, the sample apps, the license text.
task sdkCopyExtras(type: Copy) {
    group = "SDK Build"
    description = "Copy the docs/sdk-extras directory into the $buildDir/sdk directory"
    from("docs/sdk-extras") {
        exclude("hello-world/.gradle")
        exclude("**/build")
    }
    into "$buildDir/sdk"
    doLast {
        // Patch the gradle.properties file in the sample app so it uses the SDK copy of the repository.
        file("$buildDir/sdk/hello-world/gradle.properties").write("conclaveRepo=../repo\r\nconclaveVersion=${rootProject.version}")
    }
}

task sdkFiles(type: Copy, dependsOn: ["sdkRepo", "buildDocs", "zipGPL2Sources", "sdkCopyExtras"]) {
    group = "SDK Build"
    description = "Build the SDK directory tree that we ship to end users."
    from("docs/build")
    into "$buildDir/sdk/docs"
}

task sdk(type: Zip, dependsOn: ["sdkFiles"]) {
    group = "SDK Build"
    archiveFileName = "conclave-sdk-${rootProject.version}.zip"
    description = "Build the SDK downloadable file that we ship to end users."
    def outName = "conclave-sdk-${rootProject.version}"
    from("$buildDir/sdk") {
        into(outName)
    }
    doLast {
        println("SDK zip has been placed in $buildDir/distributions/$outName")
    }
}
//endregion
