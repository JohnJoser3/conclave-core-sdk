plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.3.61' apply false
    id 'com.google.protobuf' version '0.8.9' apply false
    id 'com.github.johnrengelman.shadow' version '4.0.4' apply false
    id 'org.akhikhl.gretty' version '2.0.0' apply false
    id 'net.corda.plugins.api-scanner' version '4.0.45' apply false
    id "com.github.ben-manes.versions" version "0.27.0"
    id 'base'
    id 'idea'
    id 'org.jetbrains.dokka' version '0.10.1'
}

repositories {
    jcenter()
}

static Map<String, String> createEnvironment(String... names) {
    return names.collectEntries { [(it): System.getenv(it)] }
}

ext {
    environment = createEnvironment(
            'OBLIVIUM_VERSION',
            'OBLIVIUM_DEPENDENCY_VERSION',
            'OBLIVIUM_MAVEN_URL',
            'OBLIVIUM_MAVEN_REPOSITORY',
            'OBLIVIUM_MAVEN_USERNAME',
            'OBLIVIUM_MAVEN_PASSWORD',
    )
    docker_image_release_tag = environment.OBLIVIUM_VERSION
    oblivium_dependency_version = environment.OBLIVIUM_DEPENDENCY_VERSION
}

import groovy.io.FileType

import static org.gradle.api.JavaVersion.*
// NB: For some reason IntelliJ thinks this import line is in error, but Gradle accepts it.
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

// This code allows the user to run gradle like this: ./gradlew -PexcludeNative
// and the native components will be downloaded instead of built locally. This
// can speed things up a lot if you aren't intending to change them!
def includeNative = findProperty('excludeNative') == null
def nativeSubmodulesToSubstitute = [
        ':cpp:native-host:native-host-simulation',
        ':cpp:native-host:native-host-debug',
        ':cpp:native-host:native-host-release',
        ':cpp:native-enclave:native-enclave-simulation',
        ':cpp:native-enclave:native-enclave-debug',
        ':cpp:native-enclave:native-enclave-release',
        ':cpp:native-sign-tool',
        ':cpp:native-gdb',
        ':cpp:native-binutils'
]

// Allow the user to move the default build location. This is helpful for improving the
// atrocious performance of Mac Docker, which otherwise will try to build everything on
// the super-slow osxfuse filesystem. This way it can be relocated to a (faster) Linux
// native FS, or in extremis even a ramdisk.
def topDir = project.rootDir
def buildDirLocationOverride = findProperty('buildDirOverride')
if (buildDirLocationOverride != null) {
    println("Storing build output in $buildDirLocationOverride")
    allprojects {
        buildDir = "$buildDirLocationOverride/${topDir.relativePath(project.buildDir)}"
    }
}

subprojects {
    group = "com.r3.sgx"
    version = environment.OBLIVIUM_VERSION

    repositories {
        mavenCentral()
        jcenter()
        maven {
            url = "https://software.r3.com/artifactory/sgxjvm"
            credentials {
                username = environment.OBLIVIUM_MAVEN_USERNAME
                password = environment.OBLIVIUM_MAVEN_PASSWORD
            }
        }
    }

    tasks.withType(JavaCompile) {
        sourceCompatibility = VERSION_1_8
        targetCompatibility = VERSION_1_8
    }

    tasks.withType(KotlinCompile) {
        kotlinOptions {
            jvmTarget = VERSION_1_8
            apiVersion = '1.3'
            languageVersion = '1.3'
            freeCompilerArgs = [ '-Xjvm-default=enable' ]
        }
    }

    tasks.withType(Test) {
        systemProperty 'java.io.tmpdir', buildDir.absolutePath
        failFast = true

        beforeTest { descriptor ->
            logger.lifecycle("Starting> {}.{} ({})", descriptor.classDisplayName, descriptor.displayName, descriptor.id)
        }
        afterTest { descriptor ->
            logger.lifecycle("Ending> {}.{} ({})", descriptor.classDisplayName, descriptor.displayName, descriptor.id)
        }
    }

    configurations {
        compile {
            // We want to use SLF4J's version of these bindings: jcl-over-slf4j
            // Remove any transitive dependency on Apache's version.
            exclude group: 'commons-logging', module: 'commons-logging'
        }

        // Allow -PexcludeNative to do builds with downloaded artifacts instead of locally built artifacts.
        if (includeNative) {
            all {
                for (submodule in nativeSubmodulesToSubstitute) {
                    def submoduleProject = project(submodule)
                    resolutionStrategy.dependencySubstitution {
                        substitute module("${submoduleProject.getGroup()}:${submoduleProject.getName()}") with project(submodule)
                    }
                }
            }
        }
    }
}

/* ---- PUBLISHING ---- */
class PublishedProject {
    String projectPath
    String description
}
List<PublishedProject> publishedProjects = [
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-simulation',
                description: 'Partially linked Conclave enclave linked with simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-debug',
                description: 'Partially linked Conclave enclave linked with debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-release',
                description: 'Partially linked Conclave enclave linked with release libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-simulation',
                description: 'Native Conclave host libraries linked with simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-debug',
                description: 'Native Conclave host libraries linked with debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-release',
                description: 'Native Conclave host libraries linked with release libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-gdb',
                description: 'The Intel Linux SDK gdb plugin and wrapper',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-sign-tool',
                description: 'The Intel Linux SDK signing tool',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-binutils',
                description: 'Pinned version of essential binutils tools',
        ),
        new PublishedProject(
                projectPath: ':conclave-common',
                description: 'Conclave API common to both enclave and host',
        ),
        new PublishedProject(
                projectPath: ':conclave-enclave',
                description: 'Conclave enclave API',
        ),
        new PublishedProject(
                projectPath: ':conclave-host',
                description: 'Conclave host API',
        ),
        new PublishedProject(
                projectPath: ':api-core:api-core-common',
                description: 'Core API common to both enclave and host',
        ),
        new PublishedProject(
                projectPath: ':api-core:api-core-enclave',
                description: 'Core enclave API',
        ),
        new PublishedProject(
                projectPath: ':api-core:api-core-host',
                description: 'Core enclave host API',
        ),
        new PublishedProject(
                projectPath: ':enclave-utils',
                description: 'Utility classes for working inside an enclave.',
        ),
        new PublishedProject(
                projectPath: ':enclave-testing',
                description: 'Enclave testing library',
        ),
]

// We only enable publish if native parts of the build are included.
// We create a safeguard task to check this.
task publish {
    doFirst {
        if (!includeNative) {
            throw new Exception('Native artifacts aren\'t built, not publishing')
        }
    }
}

if (includeNative) {
    for (published in publishedProjects) {
        def project = project(published.projectPath)
        def description = published.description
        project.pluginManager.apply('java')
        project.pluginManager.apply('maven-publish')
        project.publishing {
            publications {
                maven(MavenPublication) {
                    from project.components.java
                    pom.description = description
                }
            }
            repositories {
                maven {
                    name = "artifactory"
                    url = "${environment.OBLIVIUM_MAVEN_URL}/${environment.OBLIVIUM_MAVEN_REPOSITORY}"
                    credentials {
                        username = environment.OBLIVIUM_MAVEN_USERNAME
                        password = environment.OBLIVIUM_MAVEN_PASSWORD
                    }
                }
                maven {    // This section implicitly creates the  publishAllPublicationsToSdkRepoRepository target.
                    name = "sdkRepo"
                    url = "$buildDir/sdk/repo"
                }
            }
        }
    }
}

// To speed up IntelliJ indexing
idea {
    module {
        excludeDirs = [
                file("$projectDir/cpp/avian/build"),
                file("$projectDir/cpp/openjdk8"),
                file("$projectDir/cpp/.idea"),
                file("$projectDir/scripts/build")
        ]
    }
}

wrapper {
    distributionType = Wrapper.DistributionType.ALL
}


// region Docsite building
//
// This part of the build handles the creation of the EXTERNAL docsite. The internal docsite is not built automatically
// at this time: run `mkdocs serve` in the internal-docs directory yourself to view it.

// Dokka is the tool that reads KDoc comments from Kotlin and produces an API website.
dokka {
    // We will use the JavaDoc styling for now, to make Conclave more appealing to Java developers. We may do what
    // Corda does and offer a "Kotlin theme" site later.
    outputFormat = 'javadoc'

    // We output into the site source directory to avoid warnings (and associated warning blindness) caused when mkdocs
    // tries to check links to the JavaDocs and finds they're missing. This causes a bit of disk space bloat when
    // the files are copied to the docs/build directory but the cost is small and worth it.
    outputDirectory = "docs/docs/api"

    // These modules/directories contain source code defining the exported API.
    subProjects = ["conclave-common", "conclave-enclave", "conclave-host"]
    def apiDirectories = files(subProjects.collect { "$it/src/main/kotlin" })

    // Find a list of packages that shouldn't appear in the API documentation.
    def internalPackagePrefixes = {
        def prefixes = []
        // Kotlin allows packages to deviate from the directory structure, but let's assume they don't:
        apiDirectories.collect { sourceDir ->
            sourceDir.traverse(type: FileType.DIRECTORIES) {
                if (it.name == 'internal') {
                    prefixes.add sourceDir.toPath().relativize(it.toPath()).toString().replace(File.separator, '.')
                }
            }
        }
        prefixes
    }()

    configuration {
        moduleName = "Conclave"
        jdkVersion = 8
        reportUndocumented = false
        skipDeprecated = true  // Don't want users seeing deprecated stuff, they can call it up in their IDE if they need it.

        // Suppress each internal package.
        internalPackagePrefixes.collect { packagePrefix ->
            perPackageOption {
                prefix = packagePrefix
                suppress = true
            }
        }
    }
}

// This is here so we can add other Dokka formats in future (e.g. Kotlin's own API docs theme)
task apidocs(dependsOn: ['dokka'])

task mkdocs(type: Exec, dependsOn: ['apidocs']) {
    description = "Runs the mkdocs tool to produce the static HTML website we expose to end users."
    commandLine("./make-docsite.sh")
    workingDir("docs")
    inputs.files(fileTree("docs/docs"))
    outputs.dir("docs/build")
}

task cleanDocs {
    delete 'docs/build'
    delete 'docs/docs/api'
    delete 'docs/virtualenv'
}

tasks['clean'].dependsOn(cleanDocs)

// This task has to be called "buildDocs" because it's invoked by the
// https://github.com/corda/corda-docs-builder tool from CI.
task buildDocs(dependsOn: ['mkdocs'])
dokka.shouldRunAfter mkdocs
// endregion

//region SDK artifact creation
//
// This set of rules creates the tarball of the SDK that we ship to our users. It consists of a local Maven repository
// which contains all the JARs and native artifacts needed for the plugins, the docsite, and extra files like
// a readme and the patches we are obliged to release under the GPL.
//
// The publishAllPublicationsToSdkRepoRepository target is synthesised automatically by the maven-publish Gradle
// plugin, based on the repositories block inside the if(includeNative) block above.
def libArtifacts = publishedProjects.collect { "${it.projectPath}:publishAllPublicationsToSdkRepoRepository" }
task zipGPL2Sources(type: Zip) {
    description = "Zip up codebases we statically link with OpenJDK, to comply with our GPL2 obligations"
    archiveFileName = "sources.zip"
    destinationDirectory = file("$buildDir/sdk")
    reproducibleFileOrder = true
    from("cpp/avian") {
        into "avian"
        // Avian doesn't respect the default build location yet.
        exclude "build/**"
    }
    from("cpp/jvm-enclave-avian") {
        into "jvm-enclave-avian"
    }
    from("cpp/jvm-enclave-common") {
        into "jvm-enclave-common"
    }
    from("cpp/jvm-host-enclave-common") {
        into "jvm-host-enclave-common"
    }
    from("cpp/jvm-edl") {
        into "jvm-edl"
    }
}
task sdkCopyReadme(type: Copy) {
    from "docs/sdk-extras/README.md"
    into "$buildDir/sdk"
}

task sdkFiles(type: Copy, dependsOn: libArtifacts + ["buildDocs", "zipGPL2Sources", "sdkCopyReadme"]) {
    description = "Build the SDK directory tree that we ship to end users."
    from("docs/build")
    into "$buildDir/sdk/docs"
}

task sdk(type: Zip, dependsOn: ["sdkFiles"]) {
    archiveFileName = "conclave-sdk-${environment.OBLIVIUM_VERSION}.zip"
    description = "Build the SDK downloadable file that we ship to end users."
    def outName = "conclave-sdk-${environment.OBLIVIUM_VERSION}"
    from("$buildDir/sdk") {
        into(outName)
    }
    doLast {
        println("SDK zip has been placed in $buildDir/distributions/$outName")
    }
}
//endregion