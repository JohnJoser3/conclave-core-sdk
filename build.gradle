plugins {
    id 'org.jetbrains.kotlin.jvm' apply false
    id 'com.github.johnrengelman.shadow' version '6.1.0' apply false
    id "com.github.ben-manes.versions" version "0.39.0"
    id 'base'
    id 'idea'
    id 'org.jetbrains.dokka' version '1.5.0-SNAPSHOT'
    id 'com.github.jk1.dependency-license-report' version '1.16'
}

apply from: 'versions.gradle'
apply from: 'common.gradle'

repositories {
    maven {
        url "https://plugins.gradle.org/m2/"
    }
    maven {
        url "file://opt/dokka/repository"
    }
}

dependencies {
    dokkaHtmlPlugin("org.jetbrains.dokka:kotlin-as-java-plugin:1.5.0-SNAPSHOT")
}

static Map<String, String> createEnvironment(String... names) {
    return names.collectEntries { [(it): System.getenv(it)] }
}

String getConclaveRevision()  {
    String conclave_revision

    try {
        // Get the id of the last commit from the current branch
        conclave_revision = "git rev-parse HEAD".execute().text.trim()
    } catch (Exception ignored) {
        project.logger.warn("Unable to get conclave revision. Git is unavailable in build environment")
        conclave_revision = "unknown"
    }

    return conclave_revision
}

ext {
    environment = createEnvironment(
            'OBLIVIUM_MAVEN_URL',
            'OBLIVIUM_MAVEN_REPOSITORY',
            'OBLIVIUM_MAVEN_USERNAME',
            'OBLIVIUM_MAVEN_PASSWORD',
            'OBLIVIUM_CONTAINER_REGISTRY_URL'
    )

    conclave_revision = getConclaveRevision()
    project.logger.info("Conclave revision: $conclave_revision")
}

import groovy.io.FileType

// This code allows the user to run gradle like this: ./gradlew -PexcludeNative
// and the native components will be downloaded instead of built locally. This
// can speed things up a lot if you aren't intending to change them!
def includeNative = findProperty('excludeNative') == null
def nativeSubmodulesToSubstitute = [
        ':cpp:native-host:native-host-simulation',
        ':cpp:native-host:native-host-debug',
        ':cpp:native-host:native-host-release',
        ':cpp:native-host-shared',
        ':cpp:native-enclave:native-enclave-simulation',
        ':cpp:native-enclave:native-enclave-debug',
        ':cpp:native-enclave:native-enclave-release',
        ':cpp:native-sign-tool',
        ':cpp:native-gdb',
        ':cpp:native-binutils'
]

// Allow the user to move the default build location. This is helpful for improving the
// atrocious performance of Mac Docker, which otherwise will try to build everything on
// the super-slow osxfuse filesystem. This way it can be relocated to a (faster) Linux
// native FS, or in extremis even a ramdisk.
def topDir = project.rootDir
def buildDirLocationOverride = findProperty('buildDirOverride')
if (buildDirLocationOverride != null) {
    println("Storing build output in $buildDirLocationOverride")
    allprojects {
        buildDir = "$buildDirLocationOverride/${topDir.relativePath(project.buildDir)}"
    }
}

def addAttributeToManifest(Manifest manifest, String name, String value) {
    project.logger.info("Setting $name=$value")
    manifest.attributes[name] = value
}

allprojects{
    tasks.withType(Jar).configureEach { task ->
        project.logger.info("Setting extra attributes that will be added to the manifest file for jars created from project ${task.project.name}")
        addAttributeToManifest(manifest, 'Conclave-Release-Version', conclave_version)
        addAttributeToManifest(manifest, 'Conclave-Revision', conclave_revision)
    }
}

subprojects {
    repositories {
        mavenCentral()
        jcenter()
        maven {
            url = "https://software.r3.com/artifactory/sgxjvm"
            credentials {
                username = environment.OBLIVIUM_MAVEN_USERNAME
                password = environment.OBLIVIUM_MAVEN_PASSWORD
            }
        }
    }

    tasks.withType(AbstractCompile) {
        if (it.class.name.startsWith('org.jetbrains.kotlin.gradle.tasks.KotlinCompile')) {
            kotlinOptions {
                freeCompilerArgs = [ '-Xjvm-default=all', '-java-parameters' ]
            }
        }
    }

    tasks.withType(JavaCompile) {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
        options.encoding = 'UTF-8'
        options.release = 8
    }
    
    // To create deterministic builds we want to ensure all archive tasks
    // use a reproducible file order and use consistent file timestamps
    tasks.withType(AbstractArchiveTask) {
        preserveFileTimestamps = false
        reproducibleFileOrder = true
    }

    configurations {
        compile {
            // We want to use SLF4J's version of these bindings: jcl-over-slf4j
            // Remove any transitive dependency on Apache's version.
            exclude group: 'commons-logging', module: 'commons-logging'
        }

        if (project.name.startsWith("conclave-")) {
            // Shaded dependencies should not be added to the runtime classpath so they are declared as compileOnly.
            // However compileOnly does not extend to the test configuration so we add that.
            testImplementation.extendsFrom(compileOnly)
        }

        // Allow -PexcludeNative to do builds with downloaded artifacts instead of locally built artifacts.
        if (includeNative) {
            all {
                for (submodule in nativeSubmodulesToSubstitute) {
                    def submoduleProject = project(submodule)
                    resolutionStrategy.dependencySubstitution {
                        substitute module("${submoduleProject.getGroup()}:${submoduleProject.getName()}") with project(submodule)
                    }
                }
            }
        }
    }
}

// region Docsite building
//
// This part of the build handles the creation of the EXTERNAL docsite. The internal docsite is not built automatically
// at this time: run `mkdocs serve` in the internal-docs directory yourself to view it.

// Dokka is the tool that reads KDoc comments from Kotlin and produces an API website.

import org.jetbrains.dokka.gradle.DokkaTask
tasks.withType(DokkaTask).configureEach {
    moduleName.set("Conclave $conclave_version")
    dokkaSourceSets {
        register("conclave") {
            displayName.set("Conclave")
            jdkVersion.set(8)
            reportUndocumented.set(false)
            skipDeprecated.set(true)
            includeNonPublic.set(false)
            pluginsMapConfiguration.put("org.jetbrains.dokka.base.DokkaBase",
                        "{\"customAssets\":[\"${file("$projectDir/docs/assets/docs_logo.svg")}\", \"${file("$projectDir/docs/assets/arrow_down.svg")}\"], "
                      + "\"footerMessage\": \"<a href=\\\"https://docs.conclave.net\\\">&#60;&#60; Back to Conclave documentation</a>\"}")

            // Don't want users seeing deprecated stuff, they can call it up in their IDE if they need it.
            def subProjects = [
                    "conclave-common",
                    "conclave-enclave",
                    "conclave-host",
                    "conclave-client",
                    "conclave-web-host",
                    "conclave-mail"
            ]

            subProjects.forEach() {
                sourceRoots.from(file("$projectDir/$it/src/main/kotlin"))
            }

            // Filter out our internal and kotlin-specific classes
            perPackageOption {
                matchingRegex.set(".*\\.internal.*")
                suppress.set(true)
            }
            perPackageOption {
                matchingRegex.set(".*\\.kotlin.*")
                suppress.set(true)
            }
        }
    }
}

// Output HTML into the API directory for the docsite and Javadoc into a different
// directory for packaging in the documentation jar for IDEs.
tasks['dokkaHtml'].outputDirectory.set(file("$projectDir/docs/docs/api"))
tasks['dokkaJavadoc'].outputDirectory.set(file("$projectDir/docs/docs/javadoc"))

// Allow the option to exclude dokka from the SDK build.
// Important: This should only be used when building with a Java version that does not work
// with Dokka (currently anything greater than 8) to allow the SDK build to continue. It will
// result in an SDK build with the API documentation missing so should never be used for
// production builds.
def excludeDokka = findProperty('excludeDokka')
if (excludeDokka == null) {
    // Dokka does not always translate kotlin code into pure java documentation. We can use this
    // task to perform some pre-processing between generating the HTML and making the documentation site.
    task preprocessdocs(type: Exec, dependsOn: ['dokkaHtml']) {
        description = "Performs processing on the documentation generated using the apidocs task prior to running mkdocs."
        commandLine("./preprocess-docsite.sh")
        workingDir("docs")
        inputs.files(["./preprocess-docsite.sh", fileTree("docs/docs/api")])
        outputs.dir("docs/docs/api")
    }
    task packageJavadoc(type: Jar, dependsOn: ['dokkaJavadoc']) {
        from dokkaJavadoc
        archiveClassifier.set('javadoc')
    }
} else {
    // Dummy tasks to exclude dokka
    task preprocessdocs()
    task packageJavadoc(type: Jar) {
        archiveClassifier.set('javadoc')
    }
}

task mkdocs(type: Exec, dependsOn: ['preprocessdocs']) {
    description = "Runs the mkdocs tool to produce the static HTML website we expose to end users."
    commandLine("./make-docsite.sh")
    workingDir("docs")
    inputs.files(fileTree("docs/docs"))
    outputs.dir("docs/build")
}

task cleanDocs {
    delete 'docs/build'
    delete 'docs/docs/api'
    delete 'docs/virtualenv'
}

tasks['clean'].dependsOn(cleanDocs)

// This task has to be called "buildDocs" because it's invoked by the
// https://github.com/corda/corda-docs-builder tool from CI.
task buildDocs(dependsOn: ['mkdocs'])
dokkaHtml.shouldRunAfter mkdocs
// endregion

//region Publishing
class PublishedProject {
    String projectPath
    String description
}
List<PublishedProject> publishedProjects = [
        new PublishedProject(
                projectPath: ':cpp:jvm-enclave-common',
                description: 'libc common headers',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-simulation',
                description: 'Partially linked Conclave enclave linked with simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-debug',
                description: 'Partially linked Conclave enclave linked with debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-enclave:native-enclave-release',
                description: 'Partially linked Conclave enclave linked with release libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-simulation',
                description: 'Native Conclave host libraries linked with simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-debug',
                description: 'Native Conclave host libraries linked with debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host:native-host-release',
                description: 'Native Conclave host libraries linked with release libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-host-shared',
                description: 'Native Conclave host libraries shared between simulation, debug and release',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-gdb',
                description: 'The Intel Linux SDK gdb plugin and wrapper',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-sign-tool',
                description: 'The Intel Linux SDK signing tool',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-binutils',
                description: 'Pinned version of essential binutils tools',
        ),
        new PublishedProject(
                projectPath: ':cpp:linux-sgx:linux-sgx-simulation',
                description: 'SGX SDK simulation libraries and headers',
        ),
        new PublishedProject(
                projectPath: ':cpp:linux-sgx:linux-sgx-debug',
                description: 'SGX SDK debug libraries and headers',
        ),
        new PublishedProject(
                projectPath: ':cpp:linux-sgx:linux-sgx-release',
                description: 'SGX SDK release libraries and headers',
        ),
        new PublishedProject(
                projectPath: ':cpp:macos-binutils',
                description: 'Binutils for Mac OS',
        ),
        new PublishedProject(
                projectPath: ':cpp:macos-sign-tool',
                description: 'SGX sign tool for Mac OS',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-substratevm:native-substratevm-simulation',
                description: 'SubstrateVM stubs, JNI and EDL simulation libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-substratevm:native-substratevm-debug',
                description: 'SubstrateVM stubs, JNI and EDL debug libraries',
        ),
        new PublishedProject(
                projectPath: ':cpp:native-substratevm:native-substratevm-release',
                description: 'SubstrateVM stubs, JNI and EDL release libraries',
        ),
        new PublishedProject(
                projectPath: ':conclave-common',
                description: 'Conclave API common to enclave, host and client',
        ),
        new PublishedProject(
                projectPath: ':conclave-enclave',
                description: 'Conclave enclave API',
        ),
        new PublishedProject(
                projectPath: ':conclave-host',
                description: 'Conclave host API',
        ),
	    new PublishedProject(
                projectPath: ':conclave-web-host',
                description: 'Conclave web server host ',
        ),
        new PublishedProject(
                projectPath: ':conclave-client',
                description: 'Conclave client API',
        ),
        new PublishedProject(
                projectPath: ':conclave-mail',
                description: 'Conclave mail API',
        ),
        new PublishedProject(
                projectPath: ':plugin-enclave-gradle',
                description: 'Conclave Gradle plugin for creating enclaves'
        ),
        new PublishedProject(
                projectPath: ':graal',
                description: 'Graal distribution including SubstrateVM and tools'
        ),
        new PublishedProject(
                projectPath: ':containers:conclave-build',
                description: 'Conclave docker container for native-image builds'
        )
]

// We only enable publish if native parts of the build are included.
// We create a safeguard task to check this.
task publish {
    doFirst {
        if (!includeNative) {
            throw new Exception('Native artifacts aren\'t built, not publishing')
        }
    }
}

if (includeNative) {
    for (published in publishedProjects) {
        def project = project(published.projectPath)
        def description = published.description
        project.pluginManager.apply('java')
        project.pluginManager.apply('maven-publish')
        // We shade certain libraries into the Conclave API jars to avoid any potential versioning issues in Conclave apps
        // which might use different versions of these libraries.
        if (published.projectPath.startsWith(":conclave-")) {
            project.pluginManager.apply('com.github.johnrengelman.shadow')
            project.shadowJar {
                if (project.name == "conclave-mail" || project.name == "conclave-common") {
                    // Only conclave-mail and conclave-common need to have (some) of their dependencies shaded. These
                    // dependencies are in the compileOnly configuration.
                    configurations = [ project.configurations.compileOnly ]
                    exclude '**/pom.xml'
                    exclude '**/pom.properties'
                    exclude 'module-info.class'
                    mergeServiceFiles()
                    if (project.name == "conclave-mail") {
                        exclude 'kotlin/Metadata.class'
                        // Only conclave-mail, as the root in the dependency tree, will contain the shaded kotlin. Everything
                        // else depends on conclave-mail (transitively) and so will inherit the shaded version.
                        dependencies {
                            it.include(dependency("org.jetbrains.kotlin:"))
                        }
                    } else {
                        // Only conclave-common needs to contain the shaded Jackson library. Anything else that needs Jackson,
                        // e.g. conclave-host, can inherit this shaded version.
                        dependencies {
                            it.include(dependency("com.fasterxml.jackson.*:"))
                        }
                    }
                } else {
                    // The remaining modules are not shading anything so we turn it off.
                    configurations = []
                }
                exclude 'META-INF/*.kotlin_module'
                exclude '**/*.kotlin_metadata'
                exclude '**/*.kotlin_builtins'
                // Everyone needs to have their import lines modified to the new shaded ones.
                relocate 'com.fasterxml.jackson', 'com.r3.conclave.shaded.jackson'
                // Get rid of the Kotlin related stuff. We don't allow the metadata annotation to leak through because
                // it causes the IntelliJ plugin to crash, but this does unfortunately mean internal members (which are
                // public at the bytecode level) will appear. We fix this by making them synthentic which hides them from
                // the compiler.
                relocate('kotlin', 'com.r3.conclave.shaded.kotlin')
                // Replace the output of the "jar" task with this one.
                archiveClassifier = ''
            }
        }
        project.publishing {
            publications {
                maven(MavenPublication) {
                    from project.components.java
                    pom.description = description
                    // Only publish docs for the Conclave modules, as the others aren't meant to be used.
                    if (published.projectPath.startsWith(":conclave-"))
                        artifact packageJavadoc
                }
            }
            repositories {
                maven {
                    name = "artifactory"
                    url = "${environment.OBLIVIUM_MAVEN_URL}/${environment.OBLIVIUM_MAVEN_REPOSITORY}"
                    credentials {
                        username = environment.OBLIVIUM_MAVEN_USERNAME
                        password = environment.OBLIVIUM_MAVEN_PASSWORD
                    }
                }
                maven {    // This section implicitly creates the publishAllPublicationsToSdkRepoRepository target.
                    name = "sdkRepo"
                    url = "$buildDir/sdk/repo"
                }
            }
        }
    }
}

// To speed up IntelliJ indexing
idea {
    module {
        excludeDirs = [
                file("$projectDir/cpp/.idea"),
                file("$projectDir/scripts/build")
        ]
    }
}
//endregion


//region SDK artifact creation
//
// This set of rules creates the tarball of the SDK that we ship to our users. It consists of a local Maven repository
// which contains all the JARs and native artifacts needed for the plugins, the docsite, and extra files like
// a readme and the patches we are obliged to release under the GPL.
//
// The publishAllPublicationsToSdkRepoRepository target is synthesised automatically by the maven-publish Gradle
// plugin, based on the repositories block inside the if(includeNative) block above.
task cleanSDK(type: Delete) {
    delete "$buildDir/sdk/repo"
    delete "$buildDir/sdk/hello-world/client/build"
    delete "$buildDir/sdk/hello-world/enclave/build"
    delete "$buildDir/sdk/hello-world/host/build"
    delete "$buildDir/sdk/hello-world/.gradle"
}

task sdkRepo {
    dependsOn = ["cleanSDK", publishedProjects.collect { "${it.projectPath}:publishAllPublicationsToSdkRepoRepository" } ]
}

task zipGPL2Sources(type: Zip) {
    group = "SDK Build"
    description = "Zip up codebases we statically link with OpenJDK, to comply with our GPL2 obligations"
    archiveFileName = "sources.zip"
    destinationDirectory = file("$buildDir/sdk")
    reproducibleFileOrder = true
    from("cpp/jvm-enclave-common") {
        into "jvm-enclave-common"
    }
    from("cpp/jvm-host-enclave-common") {
        into "jvm-host-enclave-common"
    }
    from("cpp/jvm-edl") {
        into "jvm-edl"
    }
    from("graal/patches") {
        into "graal"
    }
}

// Copy things like the README file, the sample apps, the license text.
task sdkCopyExtras(type: Copy) {
    group = "SDK Build"
    description = "Copy the docs/sdk-extras directory into the $buildDir/sdk directory"
    from("docs/sdk-extras") {
        exclude("**/.gradle/**")
        exclude("**/build/**")
    }
    into "$buildDir/sdk"
    doLast {
        // Patch the gradle.properties file in the sample app so it uses the SDK copy of the repository.
        for (p in ["hello-world", "cordapp"]) {
            def props = new Properties()
            file("$buildDir/sdk/$p/gradle.properties").newInputStream().withCloseable {
                props.load(it)
                props["conclaveRepo"] = "../repo"
                props["conclaveVersion"] = "${rootProject.version}".toString()
            }
            file("$buildDir/sdk/$p/gradle.properties").newOutputStream().withCloseable {
                props.store(it, "")
            }
        }
    }
}

task sdkFiles(type: Copy, dependsOn: ["sdkRepo", "buildDocs", "zipGPL2Sources", "sdkCopyExtras"]) {
    group = "SDK Build"
    description = "Build the SDK directory tree that we ship to end users."
    from("docs/build")
    into "$buildDir/sdk/docs"
}

task sdk(type: Zip, dependsOn: ["sdkFiles"]) {
    group = "SDK Build"
    archiveFileName = "conclave-sdk-${rootProject.version}.zip"
    description = "Build the SDK downloadable file that we ship to end users."
    def outName = "conclave-sdk-${rootProject.version}"
    from("$buildDir/sdk") {
        into(outName)
    }
    doLast {
        println("SDK zip has been placed in $buildDir/distributions/$outName")
    }
}
//endregion

// Run gradlew dependencyLicenseReport and open build/reports/dependency-license/index.html
import com.github.jk1.license.render.*
import com.github.jk1.license.filter.*
licenseReport {
    renderers = [new InventoryHtmlReportRenderer()]
    filters = [new LicenseBundleNormalizer()]
}
