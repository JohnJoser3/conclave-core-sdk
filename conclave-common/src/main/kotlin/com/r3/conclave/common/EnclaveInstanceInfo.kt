package com.r3.conclave.common

import com.r3.conclave.common.internal.EnclaveInstanceInfoImpl
import com.r3.conclave.common.internal.SignatureSchemeEdDSA
import com.r3.conclave.common.internal.attestation.AttestationResponse
import com.r3.conclave.mail.Curve25519PublicKey
import com.r3.conclave.mail.EnclaveMail
import com.r3.conclave.mail.MutableMail
import com.r3.conclave.utilities.internal.deserialise
import com.r3.conclave.utilities.internal.readExactlyNBytes
import com.r3.conclave.utilities.internal.readIntLengthPrefixBytes
import java.security.PrivateKey
import java.security.PublicKey
import java.security.Signature
import java.security.cert.CertificateFactory

/**
 * Contains serializable information about an instantiated enclave running on a
 * specific machine, with the measurement and instance signing key verified by
 * remote attestation. The remote attestation infrastructure backing all trusted
 * computing schemes is what gives you confidence that the data in this object is
 * correct and can be trusted, as long as [securityInfo] and [enclaveInfo]
 * match what you expect.
 *
 * An [EnclaveInstanceInfo] should be fetched from the host via some app specific
 * mechanism, such as via an HTTP request, a directory service lookup, shared file
 * etc.
 *
 */
interface EnclaveInstanceInfo {
    /** Contains information about the enclave code that was loaded. */
    val enclaveInfo: EnclaveInfo

    /**
     * A key used by the enclave to digitally sign static data structures.
     * This is not the same as the enclave code signing key, which just links
     * a specific enclave file to its author.
     */
    val dataSigningKey: PublicKey

    /**
     * Returns a [Signature] object pre-initialised with [dataSigningKey], ready for the verification of digitial signatures
     * generated by the enclave.
     */
    fun verifier(): Signature

    /**
     * Exposes how secure the remote enclave is currently considered to be.
     */
    val securityInfo: EnclaveSecurityInfo

    /** Serializes this object to a custom format and returns the byte array. */
    fun serialize(): ByteArray

    /**
     * Creates a mail to this target enclave. It can be encrypted with [MutableMail.encrypt] and the results then
     * delivered to the host for onwards delivery to the enclave.
     */
    fun createMail(body: ByteArray): MutableMail

    /**
     * Decrypts mail that should have been sent by this enclave, verifying that the
     * authenticated sender matches this enclave instance. Use this in preference
     * to [com.r3.conclave.mail.Mail.decrypt], as that call doesn't check the sender
     * is the enclave.
     *
     * @param mailBytes The encrypted bytes received from a client, typically produced by
     * calling [createMail] and then [MutableMail.encrypt].
     * @param withPrivateKey Your private key - the key that the mail was sent to by the enclave,
     * i.e. provided to `Enclave.createMail` in the `to` parameter.
     */
    fun decryptMail(mailBytes: ByteArray, withPrivateKey: PrivateKey): EnclaveMail

    /**
     * Suppress kotlin specific companion objects from our API documentation.
     * The public items within the object are still published in the documentation.
     * @suppress
     */
    companion object {
        private val magic = "EII".toByteArray()
        private val signatureScheme = SignatureSchemeEdDSA()

        /**
         * Deserializes this object from its custom format.
         *
         * @throws IllegalArgumentException If the bytes are invalid.
         */
        @JvmStatic
        fun deserialize(from: ByteArray): EnclaveInstanceInfo {
            return from.deserialise {
                require(readExactlyNBytes(magic.size).contentEquals(magic)) { "Not EnclaveInstanceInfo bytes" }
                val dataSigningKey = readIntLengthPrefixBytes().let(signatureScheme::decodePublicKey)
                val encryptionKey = Curve25519PublicKey(readIntLengthPrefixBytes())
                val reportBytes = readIntLengthPrefixBytes()
                val signature = readIntLengthPrefixBytes()
                val certPath = readIntLengthPrefixBytes().inputStream().let(CertificateFactory.getInstance("X.509")::generateCertPath)
                val enclaveMode = read().let { EnclaveMode.values()[it] }
                // New fields need to be behind an availability check before being read. Use dis.available() to check if there
                // are more bytes available and only parse them if there are. If not then provide defaults.
                EnclaveInstanceInfoImpl(
                        dataSigningKey,
                        AttestationResponse(reportBytes, signature, certPath),
                        enclaveMode,
                        encryptionKey
                )
            }
        }
    }
}
