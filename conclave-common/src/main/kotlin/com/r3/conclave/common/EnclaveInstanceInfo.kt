package com.r3.conclave.common

import com.r3.conclave.common.internal.*
import com.r3.conclave.common.internal.attestation.AttestationResponse
import java.io.DataInputStream
import java.security.PublicKey
import java.security.Signature
import java.security.cert.CertificateFactory

/**
 * Contains serializable information about an instantiated enclave running on a
 * specific machine, with the measurement and instance signing key verified by
 * remote attestation. The remote attestation infrastructure backing all trusted
 * computing schemes is what gives you confidence that the data in this object is
 * correct and can be trusted, as long as [securityInfo] and [enclaveInfo]
 * match what you expect.
 *
 * An [EnclaveInstanceInfo] should be fetched from the host via some app specific
 * mechanism, such as via an HTTP request, a directory service lookup, shared file
 * etc.
 *
 */
interface EnclaveInstanceInfo {
    /** Contains information about the enclave code that was loaded. */
    val enclaveInfo: EnclaveInfo

    /**
     * A key used by the enclave to digitally sign static data structures.
     * This is not the same as the enclave code signing key, which just links
     * a specific enclave file to its author.
     */
    val dataSigningKey: PublicKey

    /**
     * Returns a [Signature] object pre-initialised with [dataSigningKey], ready for the verification of digitial signatures
     * generated by the enclave.
     */
    fun verifier(): Signature

    // TODO encryptionKey, to be added as part of Mail

    /**
     * Exposes how secure the remote enclave is currently considered to be.
     */
    val securityInfo: EnclaveSecurityInfo

    /** Serializes this object to a custom format and returns the byte array. */
    fun serialize(): ByteArray

    companion object {
        private val magic = "EII".toByteArray()
        private val signatureScheme = SignatureSchemeEdDSA()

        /**
         * Deserializes this object from its custom format.
         *
         * @throws IllegalArgumentException If the bytes are invalid.
         */
        @JvmStatic
        fun deserialize(from: ByteArray): EnclaveInstanceInfo {
            val dis = DataInputStream(from.inputStream())
            require(dis.readBytes(magic.size).contentEquals(magic)) { "Not EnclaveInstanceInfo bytes" }
            val dataSigningKey = signatureScheme.decodePublicKey(dis.readLengthPrefixBytes())
            val signedQuote = dis.readLengthPrefixBytes().let { Cursor(SgxSignedQuote(it.size), it) }
            val reportBytes = dis.readLengthPrefixBytes()
            val signature = dis.readLengthPrefixBytes()
            val certPath = CertificateFactory.getInstance("X.509").generateCertPath(dis.readLengthPrefixBytes().inputStream())
            val enclaveMode = EnclaveMode.values()[dis.read()]
            // New fields need to be behind an availablity check before being read. Use dis.available() to check if there
            // are more bytes available and only parse them if there are. If not then provide defaults.
            return EnclaveInstanceInfoImpl(
                    dataSigningKey,
                    signedQuote,
                    AttestationResponse(reportBytes, signature, certPath),
                    enclaveMode
            )
        }
    }
}
