#!/usr/bin/env python2.7

import os
import sys

if len(sys.argv) < 4:
    print("Usage: python gen_stubs.py "
          "<PATH_TO_partial_enclave> <PATH_TO_template> <PATH_TO_output_cpp> <PATH_TO_output_txt>")
    sys.exit(1)

partial_enclave = sys.argv[1]
template_path = sys.argv[2]
output_file_cpp = sys.argv[3]
output_file_txt = sys.argv[4]

# Explanation
#
# This program looks at all the symbols that are missing after linking the enclave. Missing symbols mean we can't
# complete the final link as the image must be fully linked, but, we don't have a real OS inside the enclave, and
# some of these missing symbols will actually never be used. So we just want to stub them out with trivial code
# that prints an error and dies. Here we identify the symbols we don't have:
#
# nm --undefined-only | awk       Give us the names of the symbols
# egrep -v (1|2|3)                Exclude some symbols that are special
#
# _GLOBAL_OFFSET_TABLE_           A part of ELF dynamic linking, it'll be cleaned up later.
# _binary_app_jar_start/end       These symbols mark the ranges of the boot.jar file and will be provided in the next stage.
# pcl_entry                       These symbols are related to the Protected Code Loader feature of the SGX SDK. We don't use it.
# ippcpSetCpuFeatures             Related to the tlibcrypto library which provides Intel cryptography code.
#                                 There's a weak symbol used to avoid a hard dependency from the SGX init code.

cmd = "nm --undefined-only %s | awk '{print $2}' | egrep -v '^(_GLOBAL_OFFSET_TABLE_|_binary_app_jar_start|_binary_app_jar_end|.*pcl_entry.*|ippcpSetCpuFeatures)'" % partial_enclave
os.system("echo '# This file lists all the stubbed symbols. It was generated by "
          "gen_stubs.py' >%s; %s >> %s" % (output_file_txt, cmd, output_file_txt))

entries = [l.strip() for l in open(output_file_txt, "r").readlines() if not l.startswith("#")]
entries.sort()
template_lines = file(template_path).readlines()
externs_index = template_lines.index("// STUBS HERE\n")
externs = ["STUB(%s);\n" % entry for entry in entries]
template_lines[externs_index:externs_index + 1] = externs
file(output_file_cpp, "w").writelines(template_lines)
