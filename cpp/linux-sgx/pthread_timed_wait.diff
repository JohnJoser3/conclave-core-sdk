diff --git a/common/inc/internal/se_error_internal.h b/common/inc/internal/se_error_internal.h
index ac19e47..125f4b4 100644
--- a/common/inc/internal/se_error_internal.h
+++ b/common/inc/internal/se_error_internal.h
@@ -85,6 +85,7 @@ typedef enum _se_status_internal_t
     SE_ERROR_MUTEX_GET_EVENT            = SE_INTERNAL_ERROR(0x3001),
     SE_ERROR_MUTEX_WAIT_EVENT           = SE_INTERNAL_ERROR(0x3002),
     SE_ERROR_MUTEX_WAKE_EVENT           = SE_INTERNAL_ERROR(0x3003),
+    SE_ERROR_MUTEX_TIMEDOUT             = SE_INTERNAL_ERROR(0x3004),
 } se_status_internal_t;
 
 #endif
diff --git a/common/inc/internal/se_event.h b/common/inc/internal/se_event.h
index e2a1501..878f783 100644
--- a/common/inc/internal/se_event.h
+++ b/common/inc/internal/se_event.h
@@ -44,6 +44,7 @@ typedef void * se_handle_t;
 #define SE_MUTEX_INVALID    0x1
 #define SE_MUTEX_ERROR_WAKE 0x2
 #define SE_MUTEX_ERROR_WAIT 0x3
+#define SE_MUTEX_TIMEDOUT   0x4
 
 #ifdef __cplusplus
 extern "C" {
diff --git a/common/inc/sgx_thread.h b/common/inc/sgx_thread.h
index 2be8bb4..5de4e82 100644
--- a/common/inc/sgx_thread.h
+++ b/common/inc/sgx_thread.h
@@ -101,6 +101,7 @@ int SGXAPI sgx_thread_cond_init(sgx_thread_cond_t *cond, const sgx_thread_condat
 int SGXAPI sgx_thread_cond_destroy(sgx_thread_cond_t *cond);
 
 int SGXAPI sgx_thread_cond_wait(sgx_thread_cond_t *cond, sgx_thread_mutex_t *mutex);
+int SGXAPI sgx_thread_cond_timedwait(sgx_thread_cond_t *cond, sgx_thread_mutex_t *mutex, uint64_t timeout);
 int SGXAPI sgx_thread_cond_signal(sgx_thread_cond_t *cond);
 int SGXAPI sgx_thread_cond_broadcast(sgx_thread_cond_t *cond);
 
diff --git a/common/inc/sgx_tstdc.edl b/common/inc/sgx_tstdc.edl
index 6dc006b..f965d64 100644
--- a/common/inc/sgx_tstdc.edl
+++ b/common/inc/sgx_tstdc.edl
@@ -34,7 +34,7 @@ enclave {
         [cdecl] void sgx_oc_cpuidex([out] int cpuinfo[4], int leaf, int subleaf);
         
         /* Go outside and wait on my untrusted event */
-        [cdecl] int sgx_thread_wait_untrusted_event_ocall([user_check] const void *self);
+        [cdecl] int sgx_thread_wait_untrusted_event_ocall([user_check] const void *self, size_t timeout);
 
         /* Wake a thread waiting on its untrusted event */
         [cdecl] int sgx_thread_set_untrusted_event_ocall([user_check] const void *waiter);
diff --git a/common/inc/tlibc/pthread.h b/common/inc/tlibc/pthread.h
index f59770c..fd10b0d 100644
--- a/common/inc/tlibc/pthread.h
+++ b/common/inc/tlibc/pthread.h
@@ -95,6 +95,12 @@ int SGXAPI pthread_cond_init(pthread_cond_t *, const pthread_condattr_t *);
 int SGXAPI pthread_cond_destroy(pthread_cond_t *);
 
 int SGXAPI pthread_cond_wait(pthread_cond_t *, pthread_mutex_t *);
+// R3: The posix version of this function always uses an absolute time as the timeout. We do not
+// have the concept of current time in the enclave so this version uses a relative time. Because
+// it deviates from standard pthreads it has been given a leading underscore. If you have access to
+// a time source then you can implement the standard pthread_cond_timedwait by calculating the relative
+// time then calling this function.
+int SGXAPI _pthread_cond_timedwait(pthread_cond_t *, pthread_mutex_t *, const struct timespec*);
 int SGXAPI pthread_cond_signal(pthread_cond_t *);
 int SGXAPI pthread_cond_broadcast(pthread_cond_t *);
 
diff --git a/common/src/se_event.c b/common/src/se_event.c
index b47e283..d795e53 100644
--- a/common/src/se_event.c
+++ b/common/src/se_event.c
@@ -62,6 +62,7 @@ int se_event_wait(se_handle_t se_event)
 */
 int se_event_wait_timeout(se_handle_t se_event, uint64_t timeout)
 {
+    int retval = SE_MUTEX_SUCCESS;
     if (se_event == NULL)
         return SE_MUTEX_INVALID;
 
@@ -76,10 +77,12 @@ int se_event_wait_timeout(se_handle_t se_event, uint64_t timeout)
         syscall(__NR_futex, se_event, FUTEX_WAIT, -1, &time, NULL, 0);
         //If the futex is exit with timeout (se_event still equal to ' -1'), the se_event value need reset to 0.
         //Or the event wait will unworkable in next round checking "if (__sync_fetch_and_add((int*)se_event, -1) == 0)".
-        __sync_val_compare_and_swap((int*)se_event, -1, 0);
+        if (__sync_val_compare_and_swap((int*)se_event, -1, 0) == -1) {
+            retval = SE_MUTEX_TIMEDOUT;
+        }
     }
 
-    return SE_MUTEX_SUCCESS;
+    return retval;
 }
 
 
diff --git a/external/openmp/openmp_code b/external/openmp/openmp_code
--- a/external/openmp/openmp_code
+++ b/external/openmp/openmp_code
@@ -1 +1 @@
-Subproject commit c9e7fc8c97382d61565f7ed180e4ea1cc8895b95
+Subproject commit c9e7fc8c97382d61565f7ed180e4ea1cc8895b95-dirty
diff --git a/psw/urts/enclave_mutex.cpp b/psw/urts/enclave_mutex.cpp
index bda7345..ba37767 100644
--- a/psw/urts/enclave_mutex.cpp
+++ b/psw/urts/enclave_mutex.cpp
@@ -37,7 +37,8 @@
 #include "se_error_internal.h"
 
 /* wait on untrusted event */
-extern "C" int sgx_thread_wait_untrusted_event_ocall(const void *self)
+/* R3: Takes a timeout in seconds as a paramter. Specify 0 for infinite wait. */
+extern "C" int sgx_thread_wait_untrusted_event_ocall(const void *self, size_t timeout)
 {
     if (self == NULL)
         return SGX_ERROR_INVALID_PARAMETER;
@@ -46,7 +47,10 @@ extern "C" int sgx_thread_wait_untrusted_event_ocall(const void *self)
     if (hevent == NULL)
         return SE_ERROR_MUTEX_GET_EVENT;
 
-    if (SE_MUTEX_SUCCESS != se_event_wait(hevent))
+    int retval = se_event_wait_timeout(hevent, (uint64_t)timeout);
+    if (retval == SE_MUTEX_TIMEDOUT)
+        return SE_ERROR_MUTEX_TIMEDOUT;
+    if (SE_MUTEX_SUCCESS != retval)
         return SE_ERROR_MUTEX_WAIT_EVENT;
 
     return SGX_SUCCESS;
@@ -91,5 +95,5 @@ extern "C" int sgx_thread_setwait_untrusted_events_ocall(const void *waiter, con
     int ret = sgx_thread_set_untrusted_event_ocall(waiter);
     if (ret != SGX_SUCCESS) return ret;
 
-    return sgx_thread_wait_untrusted_event_ocall(self);
+    return sgx_thread_wait_untrusted_event_ocall(self, 0);
 }
diff --git a/psw/urts/enclave_thread.cpp b/psw/urts/enclave_thread.cpp
index 9ed1e0c..5613531 100644
--- a/psw/urts/enclave_thread.cpp
+++ b/psw/urts/enclave_thread.cpp
@@ -115,7 +115,8 @@ extern "C" sgx_status_t pthread_wait_timeout_ocall(unsigned long long waiter, un
     if (hevent == NULL)
         return SGX_ERROR_DEVICE_BUSY;
 		
-    if (SE_MUTEX_SUCCESS != se_event_wait_timeout(hevent, timeout))
+    int retval = se_event_wait_timeout(hevent, timeout);
+    if ((SE_MUTEX_SUCCESS != retval) && (SE_MUTEX_TIMEDOUT != retval))
         return SGX_ERROR_UNEXPECTED;
 
     return SGX_SUCCESS;
diff --git a/sdk/pthread/pthread_cond.cpp b/sdk/pthread/pthread_cond.cpp
index 38b47be..e17ecce 100644
--- a/sdk/pthread/pthread_cond.cpp
+++ b/sdk/pthread/pthread_cond.cpp
@@ -23,9 +23,17 @@
 #include "sgx_trts.h"
 #include "sgx_spinlock.h"
 #include "pthread_imp.h"
+#include "se_error_internal.h"
 
 #include "util.h"
 
+#include <time.h>
+
+struct timespec {
+    time_t tv_sec;
+    long   tv_nsec;
+};
+
 int pthread_cond_init(pthread_cond_t *condp, const pthread_condattr_t *attr)
 {
     UNUSED(attr);
@@ -64,6 +72,32 @@ int pthread_cond_wait(pthread_cond_t *condp, pthread_mutex_t *mutexp)
     return sgx_thread_cond_wait(cond, *mutexp);
 }
 
+int _pthread_cond_timedwait(pthread_cond_t *condp, pthread_mutex_t *mutexp, const struct timespec* reltime)
+{
+    if (!reltime) {
+        return pthread_cond_wait(condp, mutexp);
+    }
+    // R3: The posix version of this function always uses an absolute time as the timeout. We do not
+    // have the concept of current time in the enclave so this version uses a relative time. Because
+    // it deviates from standard pthreads it has been given a leading underscore. If you have access to
+    // a time source then you can implement the standard pthread_cond_timedwait by calculating the relative
+    // time then calling this function.
+    uint64_t timeout = (reltime->tv_sec * 1000000000 + reltime->tv_nsec) / 1000000000;
+    if ((timeout == 0) && (reltime->tv_nsec != 0)) {
+        // The timed wait is only on 1 second granularity
+        ++timeout;
+    }
+
+    pthread_cond_t cond;
+    int error;
+    if (*condp == NULL) {
+        if ((error = pthread_cond_init(condp, NULL)))
+            return (error);
+    }
+    cond = *condp;
+    return (sgx_thread_cond_timedwait(cond, *mutexp, timeout) == (int)SE_ERROR_MUTEX_TIMEDOUT) ? ETIMEDOUT : 0;
+}
+
 int pthread_cond_signal(pthread_cond_t *condp)
 {
     pthread_cond_t cond;
diff --git a/sdk/tlibthread/sethread_cond.cpp b/sdk/tlibthread/sethread_cond.cpp
index 0dea08d..e23ac8e 100644
--- a/sdk/tlibthread/sethread_cond.cpp
+++ b/sdk/tlibthread/sethread_cond.cpp
@@ -64,7 +64,7 @@ int sgx_thread_cond_destroy(sgx_thread_cond_t *cond)
     return 0;
 }
 
-int sgx_thread_cond_wait(sgx_thread_cond_t *cond, sgx_thread_mutex_t *mutex)
+int sgx_thread_cond_timedwait(sgx_thread_cond_t *cond, sgx_thread_mutex_t *mutex, uint64_t timeout)
 {
     CHECK_PARAMETER(cond);
     CHECK_PARAMETER(mutex);
@@ -87,7 +87,7 @@ int sgx_thread_cond_wait(sgx_thread_cond_t *cond, sgx_thread_mutex_t *mutex)
         SPIN_UNLOCK(&cond->m_lock);
         /* OPT: if there is a thread waiting on the mutex, wake it in a single OCALL. */
         if (waiter == SGX_THREAD_T_NULL) {
-            sgx_thread_wait_untrusted_event_ocall(&ret, TD2TCS(self));
+            sgx_thread_wait_untrusted_event_ocall(&ret, TD2TCS(self), timeout);
         } else {
             sgx_thread_setwait_untrusted_events_ocall(&ret, TD2TCS(waiter), TD2TCS(self));
             waiter = SGX_THREAD_T_NULL;
@@ -98,12 +98,19 @@ int sgx_thread_cond_wait(sgx_thread_cond_t *cond, sgx_thread_mutex_t *mutex)
             if (tmp == self) break; /* stop searching and re-wait outside */
         }
         if (tmp == SGX_THREAD_T_NULL) break;     /* current thread isn't in the queue */
+        if (ret != 0)
+            break;
     }
 
     SPIN_UNLOCK(&cond->m_lock);
     sgx_thread_mutex_lock(mutex);
 
-    return 0;
+    return ret;
+}
+
+int sgx_thread_cond_wait(sgx_thread_cond_t *cond, sgx_thread_mutex_t *mutex)
+{
+    return sgx_thread_cond_timedwait(cond, mutex, 0);   
 }
 
 int sgx_thread_cond_signal(sgx_thread_cond_t *cond)
diff --git a/sdk/tlibthread/sethread_internal.h b/sdk/tlibthread/sethread_internal.h
index a782a95..8744eb7 100644
--- a/sdk/tlibthread/sethread_internal.h
+++ b/sdk/tlibthread/sethread_internal.h
@@ -88,7 +88,7 @@ typedef struct _thread_data_t *pTD;
 } while (0)
 
 /* Generated OCALLs */
-extern "C" sgx_status_t sgx_thread_wait_untrusted_event_ocall(int* retval, const void *self);
+extern "C" sgx_status_t sgx_thread_wait_untrusted_event_ocall(int* retval, const void *self, uint64_t timeout);
 extern "C" sgx_status_t sgx_thread_set_untrusted_event_ocall(int* retval, const void *waiter);
 extern "C" sgx_status_t sgx_thread_set_multiple_untrusted_events_ocall(int* retval, const void** waiters, size_t total);
 extern "C" sgx_status_t sgx_thread_setwait_untrusted_events_ocall(int* retval, const void *waiter, const void *self);
diff --git a/sdk/tlibthread/sethread_mutex.cpp b/sdk/tlibthread/sethread_mutex.cpp
index cc28cd1..b53b63f 100644
--- a/sdk/tlibthread/sethread_mutex.cpp
+++ b/sdk/tlibthread/sethread_mutex.cpp
@@ -117,7 +117,7 @@ int sgx_thread_mutex_lock(sgx_thread_mutex_t *mutex)
         SPIN_UNLOCK(&mutex->m_lock);
 
         int err = 0;
-        sgx_thread_wait_untrusted_event_ocall(&err, TD2TCS(self));
+        sgx_thread_wait_untrusted_event_ocall(&err, TD2TCS(self), 0);
     }
 
     /* NOTREACHED */
