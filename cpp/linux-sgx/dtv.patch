diff --git a/sdk/simulation/uinst/u_instructions.cpp b/sdk/simulation/uinst/u_instructions.cpp
index 3532a5db..687c2d78 100644
--- a/sdk/simulation/uinst/u_instructions.cpp
+++ b/sdk/simulation/uinst/u_instructions.cpp
@@ -61,7 +61,7 @@ static uintptr_t _EADD (page_info_t* pi, void* epc_lin_addr);
 static uintptr_t _EREMOVE(const void* epc_lin_addr);
 extern "C" void* get_td_addr(void);
 extern "C" bool get_elrange_start_address(void* base_address, uint64_t &elrange_start_address);
-
+static __thread uintptr_t _dtv_u = 0;

 ////////////////////////////////////////////////////////////////////////
 #define __GP__() exit(EXIT_FAILURE)
@@ -127,7 +127,7 @@ void sig_handler_sim(int signum, siginfo_t *siginfo, void *priv)
     GP_ON(signum != SIGFPE && signum != SIGSEGV);

     thread_data_t *thread_data = (thread_data_t*)get_td_addr();
-    if (thread_data != NULL && (uintptr_t)thread_data == (uintptr_t)thread_data->self_addr)
+    if (thread_data != NULL && _dtv_u != 0 && (uintptr_t)thread_data != _dtv_u && (uintptr_t)thread_data == (uintptr_t)thread_data->self_addr)
     {
         // first SSA can be used to get tcs, even cssa > 0.
         ssa_gpr_t *p_ssa_gpr = (ssa_gpr_t*)thread_data->first_ssa_gpr;
@@ -443,6 +443,9 @@ void _SE3(uintptr_t xax, uintptr_t xbx,
         GP_ON_EENTER(tcs_sim->tcs_state != TCS_STATE_INACTIVE);
         GP_ON_EENTER(tcs->cssa >= tcs->nssa);

+        if(_dtv_u == 0)
+            _dtv_u = (uintptr_t)get_td_addr();
+
         image_offset = ce->get_image_offset();
         if(image_offset!=0 && tcs_sim->tcs_offset_update_flag == false)
         {
