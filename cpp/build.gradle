import javax.inject.Inject
import java.nio.file.Paths
import java.nio.file.Files

apply plugin: "base"

def types = ["Simulation", "Debug", "Release"]

task generateHostJniHeaders(type: Javah, constructorArgs: ['com.r3.conclave.host.internal.Native']) {
    dependsOn ":conclave-host:jar"
    inputJars = files(tasks.getByPath(":conclave-host:jar").archiveFile.get().asFile)
    outputHeader = file("$projectDir/jvm-host/include/host_jni.h")
}

task generateHostSharedJniHeaders(type: Javah, constructorArgs: ['com.r3.conclave.host.internal.NativeShared']) {
    dependsOn ":conclave-host:jar"
    File conclaveHostJar = tasks.getByPath(":conclave-host:jar").archiveFile.get().asFile
    // The task cpp:generateHostSharedJniHeader started to fail after updating the properties apiVersion, languageVersion to 1.5 in the common.gradle file
    // The task :cpp:generateHostSharedJniHeaders depends on the conclave-host-*.jar and it was failing because the class io.github.classgraph.Resource could not be found.
    // To fix the issue, the path to the io.github.classgraph dependency must be given to the command javah.
    // The code below gets the compile classpath used by the task :conclave-host:jar and then gets the file classgraph-*.jar
    File dependencyJar = project(":conclave-host").configurations.compileClasspath.filter{ jarFile ->
        jarFile.name.contains("classgraph-${classgraph_version}.jar")
    }.singleFile
    inputJars = files(conclaveHostJar, dependencyJar)
    outputHeader = file("$projectDir/jvm-host-shared/include/host_jni_shared.h")
}

task generateEnclaveJniHeaders(type: Javah, constructorArgs: ['com.r3.conclave.enclave.internal.Native']) {
    dependsOn ":conclave-enclave:jar"
    inputJars = files(tasks.getByPath(":conclave-enclave:jar").archiveFile.get().asFile)
    outputHeader = file("$projectDir/jvm-enclave-common/include/enclave_jni.h")
}

/*
 * linux-sgx, native-substratevm and most of the stubs, edl libraries etc,
 * only need a debug and release versions, however they are being built
 * as part of the createCmakeBuild task, which builds the 3 flavors.
 */
String buildDirectory(type) { return "$buildDir/$type" }
static String createCmakeTaskName(type) { return "createCmakeBuild$type" }
static String compileTaskNameHost(type) { return "compileHost$type" }
static String compileTaskNameHostShared(type) { return "compileHostShared$type" }
static String compileTaskNameLinuxSgx(type) { return "compileLinuxSgx$type" }
static String compileTaskNameSubstrateVMLib(type) { return "compileSubstrateVMLib$type" }
static String compileTaskNameFatFsEnclave(type) { return "compileFatFsEnclave$type" }
static String runCppUnitTestsTaskName(type) { return "runCppUnitTests$type" }
static String symlinkTaskName(from, to) { return "symlink${from}To$to" }
static String cmakeBuildType(type) { return "-DCMAKE_BUILD_TYPE=$type" }

def symlinks = [[from: "Release", to: "Simulation"], [from: "Release", to: "Debug"], [from: "Debug", to: "Simulation"]]

for (symlink in symlinks) {
    // These variables below are needed because if we reference "symlink" inside the execution of "doFirst" process yields
    // the last "symlink" used, and not those used during the task creation.
    def from = symlink.from
    def to = symlink.to

    // Create symlinks to reduce linux-sgx sdk build time.
    tasks.create(symlinkTaskName(from, to)) {
        dependsOn(compileTaskNameLinuxSgx(from))
        doFirst {
            mkdir buildDirectory(to)
            try {
                Files.createSymbolicLink(Paths.get("${buildDirectory(to)}/linux-sgx"), Paths.get("${buildDirectory(from)}/linux-sgx"))
            } catch (ignored) {
            }
        }
        outputs.dir(buildDirectory(to))
    }
}

for (type in types) {
    // Use Cmake to create build
    tasks.create(createCmakeTaskName(type), Exec) {
        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake", cmakeBuildType(type), projectDir)

        inputs.files(
                "$projectDir/CMakeLists.txt",
                "$projectDir/*/CMakeLists.txt"
        )

        outputs.files(
                "${buildDirectory(type)}/Makefile"
        )
    }

    // Build the host object
    tasks.create(compileTaskNameHost(type), Exec) {
        dependsOn(compileTaskNameLinuxSgx(type), createCmakeTaskName(type), generateHostJniHeaders, compileTaskNameHostShared(type))

        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "jvm_host"
        )
    }

    // Build the shared host object
    tasks.create(compileTaskNameHostShared(type), Exec) {
        dependsOn(compileTaskNameLinuxSgx(type), createCmakeTaskName(type), generateHostSharedJniHeaders)

        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "jvm_host_shared"
        )
    }

    tasks.create(compileTaskNameLinuxSgx(type), Exec) {
        def buildSgxDebug = project.hasProperty("linux-sgx-debug")
        if (buildSgxDebug && type == "Simulation") {
            dependsOn(symlinkTaskName("Debug", type))
            commandLine("echo", "Linux SGX $type is a symlink from Debug.")
        } else if (!buildSgxDebug && (type == "Simulation" || type == "Debug")) {
            dependsOn(symlinkTaskName("Release", type))
            commandLine("echo", "Linux SGX $type is a symlink from Release.")
        } else {
            dependsOn(createCmakeTaskName(type))
            workingDir(buildDirectory(type))
            commandLine("/usr/bin/env", "cmake",
                    "--build", buildDirectory(type),
                    "--target", "linux-sgx-ext"
            )
        }
    }
 
    tasks.create(compileTaskNameSubstrateVMLib(type), Exec) {
        dependsOn(createCmakeTaskName(type), generateEnclaveJniHeaders)

        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "substratevm"
        )
    }

    tasks.create(compileTaskNameFatFsEnclave(type), Exec) {
        dependsOn(createCmakeTaskName(type), generateEnclaveJniHeaders)

        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "fatfs_enclave"
        )
    }

    // Run the cpp unit tests
    tasks.create(runCppUnitTestsTaskName(type), Exec) {
        dependsOn(createCmakeTaskName(type))

        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "build_tests_and_run"
        )
    }
}

class Javah extends DefaultTask {
    final String nativeClass

    @OutputFile
    File outputHeader
    @Input
    FileCollection inputJars

    @Inject
    Javah(String nativeClass) {
        this.nativeClass = nativeClass
    }

    @TaskAction
    def run() {
        project.exec { spec ->
            spec.workingDir(temporaryDir)
            spec.commandLine("/usr/bin/env", "javah",
                    "-v",
                    "-o", outputHeader,
                    "-cp", inputJars.asPath,
                    nativeClass
            )
        }
    }
}
