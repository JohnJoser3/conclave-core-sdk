import javax.inject.Inject
import java.nio.file.Paths
import java.nio.file.Files

apply plugin: "base"

def types = ["Simulation", "Debug", "Release"]

task generateHostJniHeaders(type: Javah, constructorArgs: ['com.r3.conclave.host.internal.Native']) {
    dependsOn ":conclave-host:jar"
    inputJar = tasks.getByPath(":conclave-host:jar").archiveFile.get().asFile
    outputHeader = file("$projectDir/jvm-host/include/host_jni.h")
}

task generateHostSharedJniHeaders(type: Javah, constructorArgs: ['com.r3.conclave.host.internal.NativeShared']) {
    dependsOn ":conclave-host:jar"
    inputJar = tasks.getByPath(":conclave-host:jar").archiveFile.get().asFile
    outputHeader = file("$projectDir/jvm-host-shared/include/host_jni_shared.h")
}

task generateEnclaveJniHeaders(type: Javah, constructorArgs: ['com.r3.conclave.enclave.internal.Native']) {
    dependsOn ":conclave-enclave:jar"
    inputJar = tasks.getByPath(":conclave-enclave:jar").archiveFile.get().asFile
    outputHeader = file("$projectDir/jvm-enclave-common/include/enclave_jni.h")
}

/*
 * linux-sgx, native-substratevm and most of the stubs, edl libraries etc,
 * only need a debug and release versions, however they are being built
 * as part of the createCmakeBuild task, which builds the 3 flavors.
 */
String buildDirectory(type) { return "$buildDir/$type" }
static String createCmakeTaskName(type) { return "createCmakeBuild$type" }
static String compileTaskNameEnclave(type) { return "compileEnclave$type" }
static String compileTaskNameHost(type) { return "compileHost$type" }
static String compileTaskNameHostShared(type) { return "compileHostShared$type" }
static String compileTaskNameLinuxSgx(type) { return "compileLinuxSgx$type" }
static String compileTaskNameSubstrateVMLib(type) { return "compileSubstrateVMLib$type" }

def maxWorkers = properties["org.gradle.workers.max"]

tasks.create("symlinkDebugToSimulation") {
    dependsOn(createCmakeTaskName("Debug"))
    doFirst {
        mkdir buildDirectory("Simulation")
        try {
            Files.createSymbolicLink(Paths.get("${buildDirectory("Simulation")}/linux-sgx"), Paths.get("${buildDirectory("Debug")}/linux-sgx"))
        } catch (FileAlreadyExistsException) {
        }
    }
    outputs.dir(buildDirectory("Simulation"))
}

for (type in types) {
    // Use Cmake to create build
    tasks.create(createCmakeTaskName(type), Exec) {
        environment["CMAKE_BUILD_PARALLEL_LEVEL"] = "$maxWorkers"

        if (type == "Simulation") {
            dependsOn("symlinkDebugToSimulation")
        }
        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake", "-DCMAKE_BUILD_TYPE=$type", projectDir)

        inputs.files(
                "$projectDir/CMakeLists.txt",
                "$projectDir/*/CMakeLists.txt"
        )

        outputs.files(
                "${buildDirectory(type)}/Makefile"
        )
    }

    // Build the enclave object
    tasks.create(compileTaskNameEnclave(type), Exec) {
        dependsOn(compileTaskNameLinuxSgx(type), createCmakeTaskName(type), generateEnclaveJniHeaders)


        environment["CMAKE_BUILD_PARALLEL_LEVEL"] = "$maxWorkers"
        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "jvm_enclave_avian"
        )
    }

    // Build the host object
    tasks.create(compileTaskNameHost(type), Exec) {
        dependsOn(compileTaskNameLinuxSgx(type), createCmakeTaskName(type), generateHostJniHeaders, compileTaskNameHostShared(type))

        environment["CMAKE_BUILD_PARALLEL_LEVEL"] = "$maxWorkers"
        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "jvm_host"
        )
    }

    // Build the shared host object
    tasks.create(compileTaskNameHostShared(type), Exec) {
        dependsOn(compileTaskNameLinuxSgx(type), createCmakeTaskName(type), generateHostSharedJniHeaders)

        environment["CMAKE_BUILD_PARALLEL_LEVEL"] = "$maxWorkers"
        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "jvm_host_shared"
        )
    }

    tasks.create(compileTaskNameLinuxSgx(type), Exec) {
        dependsOn(createCmakeTaskName(type))
        if(type == "Simulation") {
            dependsOn(compileTaskNameLinuxSgx("Debug"))
            commandLine("echo", "Linux SGX Simulation is a symlink from DEBUG.")
        } else {
            environment["CMAKE_BUILD_PARALLEL_LEVEL"] = "$maxWorkers"
            commandLine("/usr/bin/env", "cmake",
                    "--build", buildDirectory(type),
                    "--target", "linux-sgx-ext"
            )
            workingDir(buildDirectory(type))
        }
    }

    tasks.create(compileTaskNameSubstrateVMLib(type), Exec) {
        dependsOn(createCmakeTaskName(type))

        environment["CMAKE_BUILD_PARALLEL_LEVEL"] = "$maxWorkers"
        workingDir(buildDirectory(type))

        commandLine("/usr/bin/env", "cmake",
                "--build", buildDirectory(type),
                "--target", "substratevm"
        )
    }
}

task cleanAvian(type: Delete) {
    delete "$projectDir/avian/build"
}

clean.finalizedBy cleanAvian

class Javah extends DefaultTask {
    final String nativeClass

    @OutputFile
    File outputHeader
    @InputFile
    File inputJar

    @Inject
    Javah(String nativeClass) {
        this.nativeClass = nativeClass
    }

    @TaskAction
    def run() {
        project.exec { spec ->
            spec.workingDir(temporaryDir)
            spec.commandLine("/usr/bin/env", "javah",
                    "-v",
                    "-o", outputHeader,
                    "-cp", inputJar,
                    nativeClass
            )
        }
    }
}
