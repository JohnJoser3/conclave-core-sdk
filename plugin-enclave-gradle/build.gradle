plugins {
    id 'java-gradle-plugin'
    id 'org.jetbrains.kotlin.jvm'
}

gradlePlugin {
    plugins {
        enclavePlugin {
            id = 'com.r3.conclave.enclave'
            implementationClass = 'com.r3.conclave.plugin.enclave.gradle.GradleEnclavePlugin'
        }
    }
}

dependencies {
    implementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
    implementation "org.jetbrains.kotlin:kotlin-reflect"

    // We need conclave-common to get the hash implementations in order to be able to parse the enclave
    // metadata file.
    implementation project(":conclave-common")
    implementation "com.github.jengelman.gradle.plugins:shadow:5.2.0"
    implementation "io.github.classgraph:classgraph:$classgraph_version"
    implementation "org.bouncycastle:bcpkix-jdk15on:$bouncycastle_version"
    implementation "com.fasterxml.jackson.module:jackson-module-kotlin:$jackson_version"

    testImplementation "org.assertj:assertj-core:$assertj_version"
    testImplementation "org.junit.jupiter:junit-jupiter:$junit_jupiter_version"
}

// Bundle the various tools and components needed by the plugin to build enclaves
processResources {
    // The ld executable in this case is produced by compileLinuxSgx<Debug|Release> depending on whether the flag
    // -PnativeDebug is set or not. We do not always build ld with debug symbols because if the user sets
    // -PnativeDebug, the build will depend on both the release and debug versions of linuxSgx, meaning the SDK will
    // potentially be built twice.
    String cmakeBuildType = project.hasProperty("nativeDebug") ? "Debug" : "Release"

    dependsOn(":cpp:compileLinuxSgx$cmakeBuildType", "generateCAPCache")

    def resourcesDir = sourceSets.main.output.resourcesDir
    def cppProject = project(":cpp")

    doFirst {
        copy {
            from "${rootProject.projectDir}/containers/conclave-build"
            into "$resourcesDir/conclave-build"
        }
    }

    doFirst {
        copy {
            from "${cppProject.projectDir}/jvm-enclave-common/include/public"
            include "*.h"
            into "$resourcesDir/include"
        }
    }

    doFirst {
        String cppBuildDir = "${cppProject.buildDir}/$cmakeBuildType"
        copy {
            into "$resourcesDir/sgx-tools"
            from ("$cppBuildDir/linux-sgx/src/linux-sgx/build/linux") {
                include "sgx_sign"
            }
            from ("$cppBuildDir/linux-sgx/src/linux-sgx/external/toolset/ubuntu20.04/ld") {
                include "ld"
            }
        }
    }

    doFirst {
        copy {
            from generateCAPCache
            into "$resourcesDir/graalvm-cap-cache"
        }
    }
}

jar {
    manifest {
        // This is used in the plugin to add implicit dependencies of the right version.
        attributes("Conclave-Version": rootProject.version.toString())
    }
}

/**
 * Generates the CAP cache by running native-image on the cap-cache subproject.
 * The CAP cache is packaged in the graal jar file together with the tarball of the Graal distribution.
 * Relevant native-image options:
 * -H:±ExitAfterCAPCache    Exit image generation after C Annotation Processor Cache creation. Default: - (disabled).
 * -H:±NewCAPCache          Create a C Annotation Processor Cache. Will erase any previous cache at that same location. Default: - (disabled).
 * -H:CAPCacheDir           Directory where information generated by the CAnnotation Processor are cached.
 */
task generateCAPCache(type: Exec) {
    String capCacheDir = "${project.buildDir}/graalvm-cap-cache"
    outputs.dir(capCacheDir)

    doFirst {
        commandLine "${System.getenv("GRAAL_HOME")}/bin/native-image", '--shared',
                '-H:+ExitAfterCAPCache', '-H:+NewCAPCache', "-H:CAPCacheDir=$capCacheDir",
                "--no-fallback",
                "--language:js",
                "--language:python",
                "-H:Name=cap-cache"
    }
}
