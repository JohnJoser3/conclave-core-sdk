plugins {
    id 'java'
}

def graalMajorMinorVersion = graal_version.substring(0, graal_version.length() - 2)
def filesystemShadowJarTask = (Task) project.tasks.getByPath(':filesystem:shadowJar')
task cloneAndPatchRepository(type: Exec) {
    dependsOn filesystemShadowJarTask
    inputs.files("clone.sh", "patches/graal_${graalMajorMinorVersion}.patch", filesystemShadowJarTask.getOutputs())
    commandLine "${project.projectDir}/clone.sh", "$graalMajorMinorVersion", filesystemShadowJarTask.getOutputs().files.singleFile.toPath().toString()
    outputs.dir("${project.buildDir}/graal")
    workingDir "${project.buildDir}"
}

/**
 * From the instructions on the README.md at https://github.com/oracle/graal/tree/vm-20.1.0/vm
 *
 * The components that can be included or excluded during the graalvm build:
 * Components:
 * - GraalVM compiler ('cmp', /graal)
 * - Truffle ('tfl', /truffle)
 * - Component installer ('gu', /installer)
 * - SubstrateVM ('svm', /svm)
 * - Native Image licence files ('nil', /svm)
 * - Native Image ('ni', /svm)
 * - TRegex ('rgx', /regex)
 * - Polyglot Native API ('polynative', /polyglot)
 * - LLVM.org toolchain ('llp', /llvm)
 * - GraalVM license files ('gvm', /.)
 * - Truffle NFI ('nfi', /nfi)
 * - Truffle Macro ('tflm', /truffle)
 * - SubstrateVM LLVM ('svml', /svm)
 * - Polyglot Launcher ('poly', /polyglot)
 * - Native Image JUnit ('nju', /junit)
 * - Native Image Configure Tool ('nic', /svm)
 * - Graal.js ('js', /js)
 * - LibGraal ('lg', /False)
 * - Graal SDK ('sdk', /graalvm)
 * - Polyglot Library ('libpoly', /polyglot)
 * Launchers:
 * - gu (native)
 * - native-image (native)
 * - polyglot (native)
 * - native-image-configure (native)
 * - js (native)
 */
task buildGraal(type: Exec) {
    dependsOn cloneAndPatchRepository
    environment['JAVA_HOME'] = System.getenv('JVMCI_HOME')
    
    // MX version 5.294.1 must use Python 3 otherwise the
    // exception 'ImportError: No module named pathlib' is thrown 
    environment['MX_PYTHON_VERSION'] = 3
    
    workingDir "${project.buildDir}/graal/vm"
    // The --force-bash-launchers makes the build faster and use far less RAM by skipping the native-imaging of
    // some tools we don't use or care about. Without that flag the build can fail due to running out of RAM.
    commandLine "${System.getenv('MX_HOME')}/mx", '--skip-libraries=polyglot', '--dynamicimports', 'graalpython,graal-js,/substratevm',
        '--exclude-components=nju,nic,llp,lg,gu,polynative,gvm,poly,nil,svml', '--force-bash-launchers=python,js,polybench', 'build'
}

def outputDir = "${project.buildDir}/distributions"
def outputFile = "graalvm.tar"

def graalVMLatestDir = "${project.buildDir}/graal/vm/latest_graalvm/"
task getGraalBuildFolder(type: Exec) {
    dependsOn buildGraal
    inputs.dir(graalVMLatestDir)
    standardOutput = new ByteArrayOutputStream()
    commandLine 'ls', "$graalVMLatestDir"
    doLast {
        ext.graalVMDir = graalVMLatestDir + standardOutput.toString().replaceAll('\\r', '').replaceAll('\\n', '')
    }
}

/**
 * SubstrateVM can add required native libraries during compilation based on parameters to 
 * native-image. For example, the inclusion of --enable-all-security-services results in native-image
 * automatically including libstdc++.a during linking. We link against the SGX trusted runtime to
 * satisfy the linker so to prevent multiply derived symbols we need to provide placeholder, empty
 * implementations of any automatically linked library. This function populates the placeholderlibs/
 * directory with these files and NativeImage.kt adds this directory to the link path
 */
task generatePlaceholderLibraries(type: Exec) {
    dependsOn getGraalBuildFolder
    doFirst {
        def placeholderDir = getGraalBuildFolder.graalVMDir + "/placeholderlibs/"
        mkdir placeholderDir
        // Just create an empty archive
        commandLine 'ar', "cr", placeholderDir + "libstdc++.a"
    }
}

/**
 * The command line util `tar` is being used rather Gradle's Tar task due to
 * https://github.com/gradle/gradle/issues/3982, which describes symlinks being followed
 * rather than preserved. Graal fails to run with the resolved symlinks.
 */
task tarGraal(type: Exec) {
    dependsOn getGraalBuildFolder, generatePlaceholderLibraries

    // Set the input to the folder in which the build is generated. We actually want to tar
    // the only subdirectory from this.
    inputs.dir(graalVMLatestDir)
    doFirst {
        if (System.getenv('JVMCI_HOME').contains('openjdk1.8')) {
            commandLine 'tar', 'chf', "$outputDir/$outputFile", '-C', getGraalBuildFolder.graalVMDir, 
            "--exclude=./bin",
            "--exclude=./lib",
            "--exclude=./man",
            "--exclude=./sample",
            "--exclude=*src.zip",
            '.'
        }
        else {
            commandLine 'tar', 'chf', "$outputDir/$outputFile", '-C', getGraalBuildFolder.graalVMDir, 
            "--exclude=./lib/tools.jar",
            "--exclude=./lib/ct.sym",
            "--exclude=./lib/graalvm",
            "--exclude=./man",
            "--exclude=./sample",
            "--exclude=*src.zip",
            '.'
        }
    }
    outputs.file("$outputDir/$outputFile")
}

/**
 * Generates the CAP cache by running native-image on the cap-cache subproject.
 * The CAP cache is packaged in the graal jar file together with the tarball of the Graal distribution.
 * Relevant native-image options:
 * -H:±ExitAfterCAPCache    Exit image generation after C Annotation Processor Cache creation. Default: - (disabled).
 * -H:±NewCAPCache          Create a C Annotation Processor Cache. Will erase any previous cache at that same location. Default: - (disabled).
 * -H:CAPCacheDir           Directory where information generated by the CAnnotation Processor are cached.
 */
def capCacheDir = "${project.buildDir}/cap-cache"
task generateCAPCache(type: Exec) {
    def shadowJarTask = (Task) project.tasks.getByPath(":graal:cap-cache:shadowJar")
    def capCacheProjectShadowJar = shadowJarTask.outputs.files.first()
    def jvmEnclaveCommonJarTask = project.tasks.getByPath(":cpp:jvm-enclave-common:jar")
    def jvmEnclaveCommonJar = jvmEnclaveCommonJarTask.outputs.files.first()
    def conclaveEnclaveFatJarTask = project.tasks.getByPath(":conclave-enclave:fatJar")
    def conclaveEnclaveFatJar = conclaveEnclaveFatJarTask.outputs.files.first()
    dependsOn buildGraal, shadowJarTask, jvmEnclaveCommonJarTask, conclaveEnclaveFatJarTask, getGraalBuildFolder
    inputs.files(shadowJarTask.outputs.files.first(), capCacheProjectShadowJar, jvmEnclaveCommonJar, conclaveEnclaveFatJar)
    outputs.dir(capCacheDir)
    doFirst {
        copy {
            from zipTree(jvmEnclaveCommonJar)
            into "${project.buildDir}/include"
        }
        commandLine "${getGraalBuildFolder.graalVMDir}/bin/native-image", '--shared', '-cp', "$capCacheProjectShadowJar:$conclaveEnclaveFatJar",
                '-H:+ExitAfterCAPCache', '-H:+NewCAPCache', "-H:CAPCacheDir=$capCacheDir",
                "-H:CCompilerOption=-I${project.buildDir}/include/com/r3/conclave/include",
                "--no-fallback",
                "--language:js",
                "--language:python",
                "-H:Name=cap-cache"
    }
}

jar {
    dependsOn tarGraal, generateCAPCache
    into("com/r3/conclave/graalvm") {
        from(outputDir) {
            include outputFile
        }
    }
    into("com/r3/conclave/graalvm/cap-cache") {
        from(capCacheDir) {
            include '**/*'
        }
    }
}
