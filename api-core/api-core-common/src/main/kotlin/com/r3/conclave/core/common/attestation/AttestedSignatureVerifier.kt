package com.r3.conclave.core.common.attestation

import com.r3.conclave.core.common.crypto.SignatureSchemeId
import com.r3.conclave.core.common.crypto.internal.SignatureSchemeFactory
import java.security.*

/**
 * An helper class to deserialize, verify and authenticate signatures generated by an enclave.
 *
 * @param signatureAlgorithmSpec identifies the signature scheme in use
 * @param publicKeyAttester authenticates the signature public key
 */
class AttestedSignatureVerifier(
        val signatureSchemeId: SignatureSchemeId,
        val publicKeyAttester: PublicKeyAttester
) {
    private val signatureAlgorithm = SignatureSchemeFactory.make(signatureSchemeId)

    /**
     * Decode a public key and attest it based on the signature encoding and key attestation check
     * properties of the class
     */
    @Throws(InvalidKeyException::class)
    fun decodeAttestedKey(encodedKey: ByteArray): AttestedOutput<PublicKey> {
        return  publicKeyAttester.attest(signatureAlgorithm.decodePublicKey(encodedKey))
    }

    /**
     * Verify a signature against an attested public key
     */
    @Throws(InvalidKeyException::class, SignatureException::class)
    fun verify(attestedPublicKey: AttestedOutput<PublicKey>, signature: ByteArray, clearData: ByteArray) {
        return signatureAlgorithm.verify(attestedPublicKey.data, signature, clearData)
    }

    /**
     * Verify a signature against an attested public key in encoded form
     */
    @Throws(InvalidKeyException::class, SignatureException::class)
    fun verify(encodedPublicKey: ByteArray, signature: ByteArray, clearData: ByteArray) {
        val attestedPublicKey = decodeAttestedKey(encodedPublicKey)
        return verify(attestedPublicKey, signature, clearData)
    }
}