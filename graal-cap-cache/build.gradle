////////////////////////////////////////////////////////////////////////////////////////////////////
// Load Gradle plugins
////////////////////////////////////////////////////////////////////////////////////////////////////
plugins {
    id 'com.github.johnrengelman.shadow'
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Dependencies
////////////////////////////////////////////////////////////////////////////////////////////////////
dependencies {
    implementation project(":conclave-enclave")
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Global variables
////////////////////////////////////////////////////////////////////////////////////////////////////
ext {
    // Environment variables loaded from the system
    // Add any environment variable to the argument list if it needs to be accessible by Gradle
    environment = getEnvironmentVariables(
            'GRAAL_HOME',
    )

    // Directories and files paths
    graalDir = "$buildDir/graal"
    capCacheDir = "${project.buildDir}/cap-cache"
    outputDir = "$buildDir/distributions"
    outputFile = "graalvm.tar"
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Tasks
////////////////////////////////////////////////////////////////////////////////////////////////////
task copyGraal(type: Copy) {

    // Task details
    group = 'other'
    description = 'Copies the Graal folder into the build directory.'

    from environment.GRAAL_HOME
    into graalDir
}

/**
 * SubstrateVM can add required native libraries during compilation based on parameters to
 * native-image. For example, the inclusion of --enable-all-security-services results in native-image
 * automatically including libstdc++.a during linking. We link against the SGX trusted runtime to
 * satisfy the linker so to prevent multiply derived symbols we need to provide placeholder, empty
 * implementations of any automatically linked library. This function populates the placeholderlibs/
 * directory with these files and NativeImage.kt adds this directory to the link path
 */
task generatePlaceholderLibraries(type: Exec) {
    dependsOn copyGraal

    // Task details
    group = 'other'
    description = 'Creates and populates the placeholderlibs directory inside the Graal folder.'

    doFirst {
        def placeholderDir = graalDir + "/placeholderlibs/"
        mkdir placeholderDir
        // Just create an empty archive
        commandLine 'ar', "cr", placeholderDir + "libstdc++.a"
    }
}

task buildGraal{

    // Task details
    group = 'Build'
    description = 'Copies the Graal folder to the build directory and the placeholder library inside the new Graal folder.'

    dependsOn copyGraal, generatePlaceholderLibraries
}

/**
 * The command line util `tar` is being used rather Gradle's Tar task due to
 * https://github.com/gradle/gradle/issues/3982, which describes symlinks being followed
 * rather than preserved. Graal fails to run with the resolved symlinks.
 */
task tarGraal(type: Exec) {
    dependsOn buildGraal

    // Task details
    group = 'other'
    description = ''

    // Set the input to the folder in which the build is generated. We actually want to tar
    // the only subdirectory from this.
    inputs.dir(graalDir)
    outputs.file("$outputDir/$outputFile")

    doFirst {
        commandLine 'tar', 'chf', "$outputDir/$outputFile", '-C', graalDir,
                "--exclude=./lib/tools.jar",
                "--exclude=./lib/ct.sym",
                "--exclude=./lib/graalvm",
                "--exclude=./man",
                "--exclude=./sample",
                "--exclude=*src.zip",
                '.'
    }
}

/**
 * Generates the CAP cache by running native-image on the cap-cache subproject.
 * The CAP cache is packaged in the graal jar file together with the tarball of the Graal distribution.
 * Relevant native-image options:
 * -H:±ExitAfterCAPCache    Exit image generation after C Annotation Processor Cache creation. Default: - (disabled).
 * -H:±NewCAPCache          Create a C Annotation Processor Cache. Will erase any previous cache at that same location. Default: - (disabled).
 * -H:CAPCacheDir           Directory where information generated by the CAnnotation Processor are cached.
 */
task generateCAPCache(type: Exec) {
    def shadowJarTask = (Task) project.tasks.getByPath(":graal-cap-cache:shadowJar")
    def capCacheProjectShadowJar = shadowJarTask.outputs.files.first()
    def jvmEnclaveCommonJarTask = project.tasks.getByPath(":cpp:jvm-enclave-common:jar")
    def jvmEnclaveCommonJar = jvmEnclaveCommonJarTask.outputs.files.first()
    def conclaveEnclaveFatJarTask = project.tasks.getByPath(":conclave-enclave:fatJar")
    def conclaveEnclaveFatJar = conclaveEnclaveFatJarTask.outputs.files.first()
    dependsOn buildGraal, shadowJarTask, jvmEnclaveCommonJarTask, conclaveEnclaveFatJarTask

    // Task details
    group = 'other'
    description = ''

    inputs.files(shadowJarTask.outputs.files.first(), capCacheProjectShadowJar, jvmEnclaveCommonJar, conclaveEnclaveFatJar)
    outputs.dir(capCacheDir)

    doFirst {
        copy {
            from zipTree(jvmEnclaveCommonJar)
            into "${project.buildDir}/include"
        }
        commandLine "${graalDir}/bin/native-image", '--shared', '-cp', "$capCacheProjectShadowJar:$conclaveEnclaveFatJar",
                '-H:+ExitAfterCAPCache', '-H:+NewCAPCache', "-H:CAPCacheDir=$capCacheDir",
                "-H:CCompilerOption=-I${project.buildDir}/include/com/r3/conclave/include",
                "--no-fallback",
                "--language:js",
                "--language:python",
                "-H:Name=cap-cache"
    }
}

jar {
    dependsOn tarGraal, generateCAPCache

    into("com/r3/conclave/graalvm") {
        from(outputDir) {
            include outputFile
        }
    }

    into("com/r3/conclave/graalvm/cap-cache") {
        from(capCacheDir) {
            include '**/*'
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Helper functions
////////////////////////////////////////////////////////////////////////////////////////////////////

// The function loads the environments variables from the system
// Input: List of all environment variables that should be loaded by Gradle
// Output: A map with the environment variables that were requested
// Key of the map: environment variable name
// Value of the map: environment variable value
static Map<String, String> getEnvironmentVariables(String... envNames) {
    return envNames.collectEntries {envName -> [(envName): System.getenv(envName)?: ""] }
}
